<!DOCTYPE html>
<html>
  <head>
    <title>Workshop: Data science with R</title>
    <meta charset="utf-8">
    <meta name="author" content="Obryan Poyser" />
    <meta name="date" content="2019-03-06" />
    <link rel="stylesheet" href="css/zew-fonts.css" type="text/css" />
    <link rel="stylesheet" href="css/zew.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Workshop: Data science with R
## ZEW - Session #3
### Obryan Poyser
### 2019-03-06

---




class: inverse, middle, center

# Tidy Data and the Tidyverse

&lt;img src="img/hex-tidyverse.png" width="25%" /&gt;

---
# `dplyr`: scoped variants

Until now we have seen the main function of `dplyr`. Each serves for specific tasks relating data wrangling. Nonetheless, each of them is accompanied with special variants called "scoped functions" that serve for even more explicit problems.

In this session we are going to work with the Global Financial Inclusion Database. According to the WB *"the world’s most comprehensive data set on how adults save, borrow, make payments, and manage risk."* The DB consist on 140 different countries with representative surveys of 150K adults age 15+ for the year 2017.

The data below is a 10% sample without replacement of the whole DB.




```r
findex &lt;- readr::read_rds("datasets/global_findex/sample_findex.rds")

# There is a dictionary of the data as well.
dic &lt;- readr::read_csv("datasets/global_findex/dictionary.csv")
```

---
## Scoped variants

- `*_all()`: affects every variable. Ex:
  - `mutate_all()`
  - `summarise_all()`
  - `filter_all()`
- `*_if()`: affects variables selected with a character vector or `vars()` Ex:
  - `mutate_if()`
  - `summarise_if()`-
  - `filter_if()`
- `*_at()`: affects variables selected with a predicate function (predicate are functions that return `TRUE` or `FALSE`) Ex:
  - `mutate_at()`
  - `summarise_at()`
  - `filter_at()`

---
## `_all()`

Example: `mutate_all()`

```r
findex %&gt;%
    mutate_all(.funs = ~as.character(.))
```

```
## # A tibble: 15,492 x 32
##    economy economycode regionwb pop_adult wpid_random wgt   female age  
##    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;
##  1 Ecuador ECU         Latin A… 11679844  165556802   0.55… Female 16   
##  2 Slovak… SVK         High in… 4598181.5 143363201   2.87… Male   19   
##  3 Hungary HUN         High in… 8408621   160309868   0.63… Male   72   
##  4 Kenya   KEN         Sub-Sah… 28647916  147386743   0.67… Male   16   
##  5 Singap… SGP         High in… 4752894   182293915   0.26… Male   13   
##  6 Malays… MYS         East As… 23508496  193687149   0.89… Male   17   
##  7 Ghana   GHA         Sub-Sah… 17297232  156856982   1.82… Female 15   
##  8 Austra… AUS         High in… 19567536  170736438   0.69… Female 32   
##  9 Cambod… KHM         East As… 10814416  182298480   0.51… Female 32   
## 10 Ecuador ECU         Latin A… 11679844  127171117   0.38… Female 12   
## # … with 15,482 more rows, and 24 more variables: educ &lt;chr&gt;, inc_q &lt;chr&gt;,
## #   emp_in &lt;chr&gt;, fin2 &lt;chr&gt;, fin7 &lt;chr&gt;, fin8 &lt;chr&gt;, fin14a &lt;chr&gt;,
## #   fin14b &lt;chr&gt;, fin19 &lt;chr&gt;, fin26 &lt;chr&gt;, fin28 &lt;chr&gt;, fin32 &lt;chr&gt;,
## #   fin37 &lt;chr&gt;, mobileowner &lt;chr&gt;, account_fin &lt;chr&gt;, account_mob &lt;chr&gt;,
## #   account &lt;chr&gt;, saved &lt;chr&gt;, borrowed &lt;chr&gt;, receive_wages &lt;chr&gt;,
## #   receive_transfers &lt;chr&gt;, receive_pension &lt;chr&gt;,
## #   receive_agriculture &lt;chr&gt;, fin2_b &lt;chr&gt;
```


---
## `_if()`

Example: `mutate_if()`


```r
findex %&gt;%
    transmute_if(.predicate=is.numeric, .funs = list(log=~log(.)
                                                  , abs=~abs(.)))
```

```
## # A tibble: 15,492 x 16
##    pop_adult_log wpid_random_log wgt_log age_log receive_transfe…
##            &lt;dbl&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;            &lt;dbl&gt;
##  1          16.3            18.9  -0.590    2.77             1.39
##  2          15.3            18.8   1.05     2.94             1.39
##  3          15.9            18.9  -0.446    4.28             1.39
##  4          17.2            18.8  -0.394    2.77             1.39
##  5          15.4            19.0  -1.31     2.56             1.39
##  6          17.0            19.1  -0.109    2.83             1.39
##  7          16.7            18.9   0.603    2.71             0   
##  8          16.8            19.0  -0.369    3.47             0   
##  9          16.2            19.0  -0.659    3.47             1.39
## 10          16.3            18.7  -0.944    2.48             1.39
## # … with 15,482 more rows, and 11 more variables:
## #   receive_pension_log &lt;dbl&gt;, receive_agriculture_log &lt;dbl&gt;,
## #   fin2_b_log &lt;dbl&gt;, pop_adult_abs &lt;dbl&gt;, wpid_random_abs &lt;dbl&gt;,
## #   wgt_abs &lt;dbl&gt;, age_abs &lt;dbl&gt;, receive_transfers_abs &lt;dbl&gt;,
## #   receive_pension_abs &lt;dbl&gt;, receive_agriculture_abs &lt;dbl&gt;,
## #   fin2_b_abs &lt;dbl&gt;
```

---
## `_at()`

Example: `mutate_at()`


```r
findex %&gt;%
    transmute_at(.vars = vars(contains("fin")), .funs = ~case_when(
        .=="no" ~ 0
        , .=="yes" ~ 1
    ))
```

```
## # A tibble: 15,492 x 12
##     fin2  fin7  fin8 fin14a fin14b fin19 fin26 fin28 fin32 fin37
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     0     0    NA      0      0     0     0     0     0     0
##  2     1     1     1      1      1     0     0     0     1     0
##  3     0     0    NA      0      0     0     0     0     0     0
##  4     0     0    NA      0      0     0     0     0     0     0
##  5     1     0    NA      1      1     0     1     0     1     0
##  6     1     1     1      0      0     0     1     0     0     0
##  7     0     0    NA      0      0     1     1     0     1     1
##  8     1     1     1      1      1     1    NA    NA     0     1
##  9     0     0    NA      0      0     0     0     0     0     0
## 10     0     0    NA      0      0     0     0     1     1     0
## # … with 15,482 more rows, and 2 more variables: account_fin &lt;dbl&gt;,
## #   fin2_b &lt;dbl&gt;
```

---
## Merging data

.pl[
- Normally, one finds data distributed into several different files
- dplyr provides join functions to perform merging according to matching cells indetifiers
  &lt;!-- - `left_join()` --&gt;
  &lt;!-- - `right_join()` --&gt;
  &lt;!-- - `inner_join()` --&gt;
  &lt;!-- - `full_join()` --&gt;
  &lt;!-- - `anti_join()` --&gt;
  &lt;!-- - `semi_join()` --&gt;

&lt;img src="img/join2.png" width="50%" style="display: block; margin: auto;" /&gt;

  ]
  
.pr[
  
- Also it is possible to combine datasets when they share the same column names with `bind_cols()`

&lt;img src="img/join1.png" width="60%" style="display: block; margin: auto;" /&gt;

- Or rows with `bind_rows()`

&lt;img src="img/join3.png" width="40%" style="display: block; margin: auto;" /&gt;

]

---
## Merging data: example

.pl[

```r
(df1 &lt;- tibble::tribble(
    ~col1, ~col2, ~col3,
      "a",     1,     3,
      "b",    NA,     5,
      "b",     5,     6
    ))
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
(df2 &lt;- tibble::tribble(
           ~col1, ~col2, ~col4,
             "a",     1,  TRUE,
             "b",    NA, FALSE,
             "b",     6, FALSE,
             "c",    10, FALSE
           ))
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[

```r
(list_df &lt;- list(e1=df1, e2=df1, e3=df2))
```

```
## $e1
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
## 
## $e2
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
## 
## $e3
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```

]

---
## Merging data: left and right

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[


```r
# left_join(): matches values from df2 to df1
df1 %&gt;%
    left_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 3 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         5     6 NA
```


```r
# right_join(): matches valyes from df1 to df2
df1 %&gt;%
    right_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 4 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         6    NA FALSE
## 4 c        10    NA FALSE
```
]

---
## Merging data: inner and full

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[

```r
# inner_join(): retain only the rows with matches
df1 %&gt;%
    inner_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 2 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
```

```r
# full_join(): retain all values, all rows
df1 %&gt;%
    full_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 5 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         5     6 NA   
## 4 b         6    NA FALSE
## 5 c        10    NA FALSE
```
]

---
## Merging data: semi and anti

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[

```r
# semi_join(): returns rows of df1 that have match in df2
df1 %&gt;%
    semi_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 2 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
```


```r
# anti_join(): return rows of df1 that do not have a match in df2
df1 %&gt;%
*   anti_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 1 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 b         5     6
```
]

---
## Merging data: by row/column

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]


.pr[

```r
# bind_rows: When row-binding, columns are matched by name, 
# and any missing columns will be filled with NA.
df1 %&gt;%
    bind_rows(df2)
```

```
## # A tibble: 7 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 NA   
## 2 b        NA     5 NA   
## 3 b         5     6 NA   
## 4 a         1    NA TRUE 
## 5 b        NA    NA FALSE
## 6 b         6    NA FALSE
## 7 c        10    NA FALSE
```


```r
# bind_cols: rows are matched by position, 
# so all data frames must have the same number of rows.
df1 %&gt;%
    bind_cols(df1)
```

```
## # A tibble: 3 x 6
##   col1   col2  col3 col11 col21 col31
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3 a         1     3
## 2 b        NA     5 b        NA     5
## 3 b         5     6 b         5     6
```
]

---
## Merging data: advanced stuff


- Join functions have a `by=` argument to match specific columns.
- If two matching columns have different names one can specify such details by:


```r
data1 %&gt;%
    left_join(by = c("var1"="var2"))
```
--

.pl[
Notice the difference between:


```r
df1 %&gt;%
    left_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 3 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         5     6 NA
```
]

.pr[
and...

```r
df1 %&gt;%
    left_join(df2, by="col1")
```

```
## # A tibble: 5 x 5
##   col1  col2.x  col3 col2.y col4 
##   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;
## 1 a          1     3      1 TRUE 
## 2 b         NA     5     NA FALSE
## 3 b         NA     5      6 FALSE
## 4 b          5     6     NA FALSE
## 5 b          5     6      6 FALSE
```
]

---
## Merging data: advanced stuff

.pl[
- What can we do if there are several separated datasets we want to:
    1. join?
    1. bind?
- According to the approach followed in the last slides it is necessary to call the join function per object, like:


```r
df1 %&gt;%
    left_join(df2) %&gt;%
    left_join(df3) %&gt;% ...
```

- However, there is a powerful and intuitive way to execute this task with the reduce function, which is also embedded in the package `purrr`. Therefore the problem could be solved only by specifying the list of dataframes and then applying the joining function recursively. Example:]

.pr[


```r
list(df1, df1, df2) %&gt;%
    reduce(.f = left_join, by="col1"
           , suffix=c("_iter1", "_iter2"))
```

```
## # A tibble: 9 x 7
##   col1  col2_iter1 col3_iter1 col2_iter2 col3_iter2  col2 col4 
##   &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a              1          3          1          3     1 TRUE 
## 2 b             NA          5         NA          5    NA FALSE
## 3 b             NA          5         NA          5     6 FALSE
## 4 b             NA          5          5          6    NA FALSE
## 5 b             NA          5          5          6     6 FALSE
## 6 b              5          6         NA          5    NA FALSE
## 7 b              5          6         NA          5     6 FALSE
## 8 b              5          6          5          6    NA FALSE
## 9 b              5          6          5          6     6 FALSE
```
]
---
# `tidyr`

- The main purpose of `tidyr` is to create tidy data
- There are 2 main functions for converting long to wide data and viceversa, plus other 2 useful for separating tasks.
    - `gather()`: takes multiple columns, and gathers them into key-value pairs: it makes “wide” data longer.
    - `spread()`: takes two columns (key &amp; value), and spreads into multiple columns: it makes “long” data wider.
    - `separate()`: pull apart columns that represent multiple variables
    - `extract()`: turns each group into a new column
    
---
### `gather()`

.pl[

```r
(df1 &lt;- df1 %&gt;%
    mutate(obs=1:3))
```

```
## # A tibble: 3 x 4
##   col1   col2  col3   obs
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;
## 1 a         1     3     1
## 2 b        NA     5     2
## 3 b         5     6     3
```


```r
df1 %&gt;%
    gather(key = "key", value = "data")
```

```
## # A tibble: 12 x 2
##    key   data 
##    &lt;chr&gt; &lt;chr&gt;
##  1 col1  a    
##  2 col1  b    
##  3 col1  b    
##  4 col2  1    
##  5 col2  &lt;NA&gt; 
##  6 col2  5    
##  7 col3  3    
##  8 col3  5    
##  9 col3  6    
## 10 obs   1    
## 11 obs   2    
## 12 obs   3
```
]

.pr[

```r
(df1_long &lt;- df1 %&gt;%
    gather(key = "key", value = "data"
*          , -obs)
 )
```

```
## # A tibble: 9 x 3
##     obs key   data 
##   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 col1  a    
## 2     2 col1  b    
## 3     3 col1  b    
## 4     1 col2  1    
## 5     2 col2  &lt;NA&gt; 
## 6     3 col2  5    
## 7     1 col3  3    
## 8     2 col3  5    
## 9     3 col3  6
```
]

---
## `spread()`
.pl[

```r
(df1_long &lt;- df1_long %&gt;%
    mutate(new_var=paste0(data, "-", data)))
```

```
## # A tibble: 9 x 4
##     obs key   data  new_var
##   &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  
## 1     1 col1  a     a-a    
## 2     2 col1  b     b-b    
## 3     3 col1  b     b-b    
## 4     1 col2  1     1-1    
## 5     2 col2  &lt;NA&gt;  NA-NA  
## 6     3 col2  5     5-5    
## 7     1 col3  3     3-3    
## 8     2 col3  5     5-5    
## 9     3 col3  6     6-6
```
]

.pr[

```r
df1_long %&gt;%
    spread(key = key, value = data)
```

```
## # A tibble: 9 x 5
##     obs new_var col1  col2  col3 
##   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 1-1     &lt;NA&gt;  1     &lt;NA&gt; 
## 2     1 3-3     &lt;NA&gt;  &lt;NA&gt;  3    
## 3     1 a-a     a     &lt;NA&gt;  &lt;NA&gt; 
## 4     2 5-5     &lt;NA&gt;  &lt;NA&gt;  5    
## 5     2 b-b     b     &lt;NA&gt;  &lt;NA&gt; 
## 6     2 NA-NA   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; 
## 7     3 5-5     &lt;NA&gt;  5     &lt;NA&gt; 
## 8     3 6-6     &lt;NA&gt;  &lt;NA&gt;  6    
## 9     3 b-b     b     &lt;NA&gt;  &lt;NA&gt;
```
]

---
## `separate()`

.pl[

```r
df1_long %&gt;%
    separate(new_var, into = c("var1", "var2"), sep = "-")
```

```
## # A tibble: 9 x 5
##     obs key   data  var1  var2 
##   &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 col1  a     a     a    
## 2     2 col1  b     b     b    
## 3     3 col1  b     b     b    
## 4     1 col2  1     1     1    
## 5     2 col2  &lt;NA&gt;  NA    NA   
## 6     3 col2  5     5     5    
## 7     1 col3  3     3     3    
## 8     2 col3  5     5     5    
## 9     3 col3  6     6     6
```
]

.pr[

```r
sv &lt;- tibble(id=1:3, q1=c("1", "1,2", "1,3,4"))
sv %&gt;%
    separate_rows(q1)
```

```
## # A tibble: 6 x 2
##      id q1   
##   &lt;int&gt; &lt;chr&gt;
## 1     1 1    
## 2     2 1    
## 3     2 2    
## 4     3 1    
## 5     3 3    
## 6     3 4
```
]

---
# `purrr`

.pl[
- Toolkit by providing a complete and consistent set of tools for working with functions and vectors.
- Allow you to replace many for loops with code that is both more succinct and easier to read.
- `purrr` has docenzs of functions, some could be overly complex. However, must of the time we will use the most basic function called `map()`
    - The `map_*()` functions transform their input by applying a function to each element and returning a vector the same length as the input.
    - `map()` is a powered `apply()`!


```r
lapply(X = letters[1:3], FUN = function(x) return(x))
```

```
## [[1]]
## [1] "a"
## 
## [[2]]
## [1] "b"
## 
## [[3]]
## [1] "c"
```
]

.pr[

```r
map(.x = letters[1:3], .f = function(x) return(x)) # explicit functions
```

```
## [[1]]
## [1] "a"
## 
## [[2]]
## [1] "b"
## 
## [[3]]
## [1] "c"
```

```r
map(.x = letters[1:3], .f = ~return(.)) # implicit functions
```

```
## [[1]]
## [1] "a"
## 
## [[2]]
## [1] "b"
## 
## [[3]]
## [1] "c"
```
]
---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
     group_by(economy, regionwb))
```

```
## # A tibble: 15,492 x 32
## # Groups:   economy, regionwb [144]
##    economy economycode regionwb pop_adult wpid_random   wgt female   age
##    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt;
##  1 Ecuador ECU         Latin A… 11679844    165556802 0.554 Female    16
##  2 Slovak… SVK         High in…  4598182.   143363201 2.87  Male      19
##  3 Hungary HUN         High in…  8408621    160309868 0.640 Male      72
##  4 Kenya   KEN         Sub-Sah… 28647916    147386743 0.674 Male      16
##  5 Singap… SGP         High in…  4752894    182293915 0.269 Male      13
##  6 Malays… MYS         East As… 23508496    193687149 0.896 Male      17
##  7 Ghana   GHA         Sub-Sah… 17297232    156856982 1.83  Female    15
##  8 Austra… AUS         High in… 19567536    170736438 0.692 Female    32
##  9 Cambod… KHM         East As… 10814416    182298480 0.517 Female    32
## 10 Ecuador ECU         Latin A… 11679844    127171117 0.389 Female    12
## # … with 15,482 more rows, and 24 more variables: educ &lt;fct&gt;, inc_q &lt;fct&gt;,
## #   emp_in &lt;fct&gt;, fin2 &lt;fct&gt;, fin7 &lt;fct&gt;, fin8 &lt;fct&gt;, fin14a &lt;fct&gt;,
## #   fin14b &lt;fct&gt;, fin19 &lt;fct&gt;, fin26 &lt;fct&gt;, fin28 &lt;fct&gt;, fin32 &lt;fct&gt;,
## #   fin37 &lt;fct&gt;, mobileowner &lt;fct&gt;, account_fin &lt;fct&gt;, account_mob &lt;fct&gt;,
## #   account &lt;fct&gt;, saved &lt;fct&gt;, borrowed &lt;fct&gt;, receive_wages &lt;fct&gt;,
## #   receive_transfers &lt;dbl&gt;, receive_pension &lt;dbl&gt;,
## #   receive_agriculture &lt;dbl&gt;, fin2_b &lt;dbl&gt;
```

---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
     group_by(economy, regionwb) %&gt;% 
     nest() # take every peace of data associated with the group
 )
```

```
## # A tibble: 144 x 3
##    economy        regionwb                                 data            
##    &lt;chr&gt;          &lt;chr&gt;                                    &lt;list&gt;          
##  1 Ecuador        Latin America &amp; Caribbean (excluding hi… &lt;tibble [100 × …
##  2 Slovak Republ… High income: OECD                        &lt;tibble [87 × 3…
##  3 Hungary        High income: nonOECD                     &lt;tibble [109 × …
##  4 Kenya          Sub-Saharan Africa (excluding high inco… &lt;tibble [94 × 3…
##  5 Singapore      High income: nonOECD                     &lt;tibble [98 × 3…
##  6 Malaysia       East Asia &amp; Pacific (excluding high inc… &lt;tibble [96 × 3…
##  7 Ghana          Sub-Saharan Africa (excluding high inco… &lt;tibble [101 × …
##  8 Australia      High income: OECD                        &lt;tibble [93 × 3…
##  9 Cambodia       East Asia &amp; Pacific (excluding high inc… &lt;tibble [164 × …
## 10 Greece         High income: OECD                        &lt;tibble [79 × 3…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
    group_nest(economy, regionwb) %&gt;% # Notice that there is a function that does the =
    mutate(model=map(data # loop over each element of the column data
                     , ~glm(fin2_b~pop_adult+female+age+educ # specification
                            , data = . # the dot is interpreted as every value of data
                            , family = binomial() # link function
                            )
                     )
           )
 )
```

```
## # A tibble: 144 x 4
##    economy    regionwb                              data            model  
##    &lt;chr&gt;      &lt;chr&gt;                                 &lt;list&gt;          &lt;list&gt; 
##  1 Afghanist… South Asia                            &lt;tibble [95 × … &lt;S3: g…
##  2 Albania    Europe &amp; Central Asia (excluding hig… &lt;tibble [107 ×… &lt;S3: g…
##  3 Algeria    Middle East &amp; North Africa (excludin… &lt;tibble [112 ×… &lt;S3: g…
##  4 Argentina  Latin America &amp; Caribbean (excluding… &lt;tibble [108 ×… &lt;S3: g…
##  5 Armenia    Europe &amp; Central Asia (excluding hig… &lt;tibble [95 × … &lt;S3: g…
##  6 Australia  High income: OECD                     &lt;tibble [93 × … &lt;S3: g…
##  7 Austria    High income: OECD                     &lt;tibble [108 ×… &lt;S3: g…
##  8 Azerbaijan Europe &amp; Central Asia (excluding hig… &lt;tibble [94 × … &lt;S3: g…
##  9 Bahrain    High income: nonOECD                  &lt;tibble [113 ×… &lt;S3: g…
## 10 Bangladesh South Asia                            &lt;tibble [98 × … &lt;S3: g…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
    group_nest(economy, regionwb) %&gt;%
    mutate(model=map(data
                     , ~glm(fin2_b~female+age+educ
                            , data = .
                            , family = binomial()
                            )
                     )
           , coef=map(model, tidy) # coefficients as tibble
           , stats=map(model, glance) # summary statistics
           , fitted=map(model, augment) # adds info on each observation
           ) 
 )
```

```
## # A tibble: 144 x 7
##    economy   regionwb            data      model  coef    stats   fitted   
##    &lt;chr&gt;     &lt;chr&gt;               &lt;list&gt;    &lt;list&gt; &lt;list&gt;  &lt;list&gt;  &lt;list&gt;   
##  1 Afghanis… South Asia          &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  2 Albania   Europe &amp; Central A… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  3 Algeria   Middle East &amp; Nort… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  4 Argentina Latin America &amp; Ca… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  5 Armenia   Europe &amp; Central A… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  6 Australia High income: OECD   &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  7 Austria   High income: OECD   &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  8 Azerbaij… Europe &amp; Central A… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  9 Bahrain   High income: nonOE… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
## 10 Banglade… South Asia          &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power


```r
findex_model$coef[[1]]
```

```
## # A tibble: 5 x 5
##   term                           estimate  std.error   statistic p.value
##   &lt;chr&gt;                             &lt;dbl&gt;      &lt;dbl&gt;       &lt;dbl&gt;   &lt;dbl&gt;
## 1 (Intercept)                    -23.5     8358.     -0.00281      0.998
## 2 femaleFemale                     0.0881 10612.      0.00000830   1.000
## 3 age                              0.0351     0.0994  0.353        0.724
## 4 educsecondary                    0.501  14975.      0.0000335    1.000
## 5 educcompleted tertiary or more  21.9     8358.      0.00262      0.998
```


---
# `purrr`: unleashing the true power

Let's extract the log odds gender==female

```r
(findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale")
                           )
           )
 )
```

```
## # A tibble: 144 x 8
##    economy  regionwb       data    model  coef   stats  fitted  female_coef
##    &lt;chr&gt;    &lt;chr&gt;          &lt;list&gt;  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;  &lt;list&gt;     
##  1 Afghani… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  2 Albania  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  3 Algeria  Middle East &amp;… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  4 Argenti… Latin America… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  5 Armenia  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  6 Austral… High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  7 Austria  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  8 Azerbai… Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  9 Bahrain  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## 10 Banglad… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## # … with 134 more rows
```


---
# `purrr`: unleashing the true power

Why not calculing confidence intervals? and extracting the relevant variables

```r
(findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale") %&gt;%
                            mutate(min_int=estimate-1.96*std.error
                                   , max_int=estimate+1.96*std.error) %&gt;% 
                            dplyr::select(estimate, p.value, contains("int")
                                          )
                           )
           )
 )
```

```
## # A tibble: 144 x 8
##    economy  regionwb       data    model  coef   stats  fitted  female_coef
##    &lt;chr&gt;    &lt;chr&gt;          &lt;list&gt;  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;  &lt;list&gt;     
##  1 Afghani… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  2 Albania  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  3 Algeria  Middle East &amp;… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  4 Argenti… Latin America… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  5 Armenia  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  6 Austral… High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  7 Austria  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  8 Azerbai… Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  9 Bahrain  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## 10 Banglad… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power

Let's get rid of the columns that we are not interested


```r
(findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale") %&gt;%
                            mutate(min_int=estimate-1.96*std.error
                                   , max_int=estimate+1.96*std.error) %&gt;% 
                            dplyr::select(estimate, p.value, contains("int")
                                          )
                           )
           ) %&gt;% 
     dplyr::select(economy, regionwb, female_coef)
 )
```

```
## # A tibble: 144 x 3
##    economy     regionwb                                     female_coef    
##    &lt;chr&gt;       &lt;chr&gt;                                        &lt;list&gt;         
##  1 Afghanistan South Asia                                   &lt;tibble [1 × 4…
##  2 Albania     Europe &amp; Central Asia (excluding high incom… &lt;tibble [1 × 4…
##  3 Algeria     Middle East &amp; North Africa (excluding high … &lt;tibble [1 × 4…
##  4 Argentina   Latin America &amp; Caribbean (excluding high i… &lt;tibble [1 × 4…
##  5 Armenia     Europe &amp; Central Asia (excluding high incom… &lt;tibble [1 × 4…
##  6 Australia   High income: OECD                            &lt;tibble [1 × 4…
##  7 Austria     High income: OECD                            &lt;tibble [1 × 4…
##  8 Azerbaijan  Europe &amp; Central Asia (excluding high incom… &lt;tibble [1 × 4…
##  9 Bahrain     High income: nonOECD                         &lt;tibble [1 × 4…
## 10 Bangladesh  South Asia                                   &lt;tibble [1 × 4…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power

What's inside female_coef?


```r
(findex_model &lt;- findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale") %&gt;%
                            mutate(min_int=estimate-1.96*std.error
                                   , max_int=estimate+1.96*std.error) %&gt;% 
                            dplyr::select(estimate, p.value, contains("int")
                                          )
                           )
           ) %&gt;% 
     dplyr::select(economy, regionwb, female_coef) %&gt;% 
     unnest(female_coef)
 )
```

```
## # A tibble: 144 x 6
##    economy   regionwb                    estimate p.value   min_int max_int
##    &lt;chr&gt;     &lt;chr&gt;                          &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;   &lt;dbl&gt;
##  1 Afghanis… South Asia                    0.0881   1.000  -2.08e+4 2.08e+4
##  2 Albania   Europe &amp; Central Asia (exc…  -0.303    0.495  -1.18e+0 5.68e-1
##  3 Algeria   Middle East &amp; North Africa…  -0.111    0.817  -1.05e+0 8.28e-1
##  4 Argentina Latin America &amp; Caribbean …   0.590    0.192  -2.97e-1 1.48e+0
##  5 Armenia   Europe &amp; Central Asia (exc…  -0.365    0.459  -1.33e+0 6.00e-1
##  6 Australia High income: OECD             0.875    0.312  -8.21e-1 2.57e+0
##  7 Austria   High income: OECD            -0.687    0.277  -1.92e+0 5.51e-1
##  8 Azerbaij… Europe &amp; Central Asia (exc…   0.579    0.307  -5.31e-1 1.69e+0
##  9 Bahrain   High income: nonOECD         -0.183    0.802  -1.62e+0 1.25e+0
## 10 Banglade… South Asia                   -1.14     0.235  -3.01e+0 7.41e-1
## # … with 134 more rows
```


---
# `purrr`: unleashing the true power

Little exploration maybe?


```r
findex_model %&gt;% summary()
```

```
##    economy            regionwb            estimate           p.value      
##  Length:144         Length:144         Min.   :-19.6041   Min.   :0.0000  
##  Class :character   Class :character   1st Qu.: -0.8535   1st Qu.:0.1325  
##  Mode  :character   Mode  :character   Median : -0.3553   Median :0.3957  
##                                        Mean   : -0.7472   Mean   :0.4506  
##                                        3rd Qu.:  0.1508   3rd Qu.:0.7502  
##                                        Max.   : 22.2231   Max.   :1.0000  
##     min_int              max_int         
##  Min.   :-20799.256   Min.   :   -0.918  
##  1st Qu.:    -2.223   1st Qu.:    0.363  
##  Median :    -1.525   Median :    0.876  
##  Mean   :  -629.369   Mean   :  627.875  
##  3rd Qu.:    -1.018   3rd Qu.:    1.640  
##  Max.   :     0.226   Max.   :20799.432
```

---
# `purrr`: unleashing the true power

The natural question is "why", but for the sake of the exercise we are going to truncate the data and keep the record that lie between the 10% and 90% percentile of the lower confidence interval

```r
(findex_model_coef &lt;- findex_model %&gt;%
    filter_at(.vars = vars(min_int)
              , .vars_predicate = any_vars(between(., quantile(., 0.1)
                                                   , quantile(., 0.9)
                                                   )
                                           )
              ) )
```

```
## # A tibble: 114 x 6
##    economy   regionwb                      estimate p.value min_int max_int
##    &lt;chr&gt;     &lt;chr&gt;                            &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 Albania   Europe &amp; Central Asia (exclu…  -0.303    0.495  -1.18    0.568
##  2 Algeria   Middle East &amp; North Africa (…  -0.111    0.817  -1.05    0.828
##  3 Armenia   Europe &amp; Central Asia (exclu…  -0.365    0.459  -1.33    0.600
##  4 Australia High income: OECD               0.875    0.312  -0.821   2.57 
##  5 Austria   High income: OECD              -0.687    0.277  -1.92    0.551
##  6 Bahrain   High income: nonOECD           -0.183    0.802  -1.62    1.25 
##  7 Banglade… South Asia                     -1.14     0.235  -3.01    0.741
##  8 Belgium   High income: OECD               0.0101   0.993  -2.22    2.24 
##  9 Benin     Sub-Saharan Africa (excludin…   1.30     0.193  -0.654   3.25 
## 10 Bolivia   Latin America &amp; Caribbean (e…  -0.568    0.243  -1.52    0.385
## # … with 104 more rows
```

---
# `purrr`: unleashing the true power

.pl[

```r
g0 &lt;- findex_model_coef %&gt;% 
    qplot(min_int, geom = "density", data = ., ylab = "density")+
    scale_x_continuous(limits = c(-5, 0))
```
]

.pr[
![](ws_3_files/figure-html/unnamed-chunk-50-1.png)&lt;!-- --&gt;
]

---
# `purrr`: unleashing the true power

.pl[


```r
g1 &lt;- findex_model_coef %&gt;%
    filter(grepl(regionwb, pattern = "High")) %&gt;%
    ggplot() +
    geom_point(aes(economy, estimate, col=economy))+
    geom_linerange(aes(ymin=min_int, ymax=max_int, x=economy))+
    geom_hline(yintercept = 0, linetype="dotted", col="red")+
    coord_flip()+
    facet_wrap(~regionwb)
```
]

.pr[
![](ws_3_files/figure-html/unnamed-chunk-52-1.png)&lt;!-- --&gt;
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-dark",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
