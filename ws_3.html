<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
  <head>
    <title>Workshop: Data science with R (ZEW)</title>
    <meta charset="utf-8" />
    <meta name="author" content="Obryan Poyser" />
    <meta name="date" content="2019-03-06" />
    <link rel="stylesheet" href="css/zew-fonts.css" type="text/css" />
    <link rel="stylesheet" href="css/zew.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Workshop: Data science with R (ZEW)
## Session #3: Data wrangling (cont.)
### Obryan Poyser
### 2019-03-06

---




class: inverse, middle, center

# Tidy Data and the Tidyverse

&lt;img src="img/hex-tidyverse.png" width="25%" /&gt;

---
# `dplyr`: scoped variants

Until now we have seen the main function of `dplyr`. Each serves for specific tasks relating data wrangling. Nonetheless, each of them is accompanied with special variants called "scoped functions" that serve for even more explicit problems.

In this session we are going to work with the Global Financial Inclusion Database. According to the WB *"the world’s most comprehensive data set on how adults save, borrow, make payments, and manage risk."* The DB consist on 140 different countries with representative surveys of 150K adults age 15+ for the year 2017.

The data below is a 10% sample without replacement of the whole DB.




```r
findex &lt;- readr::read_rds("datasets/global_findex/sample_findex.rds")

# There is a dictionary of the data as well.
dic &lt;- readr::read_csv("datasets/global_findex/dictionary.csv")
```

---
## Scoped variants

- `*_all()`: affects every variable. Ex:
  - `mutate_all()`
  - `summarise_all()`
  - `filter_all()`
- `*_if()`: affects variables selected with a character vector or `vars()` Ex:
  - `mutate_if()`
  - `summarise_if()`-
  - `filter_if()`
- `*_at()`: affects variables selected with a predicate function (predicate are functions that return `TRUE` or `FALSE`) Ex:
  - `mutate_at()`
  - `summarise_at()`
  - `filter_at()`

---
## `_all()`

Example: `mutate_all()`

```r
findex %&gt;%
    mutate_all(.funs = ~as.character(.))
```

```
## # A tibble: 15,492 x 32
##    economy economycode regionwb pop_adult wpid_random wgt   female age  
##    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;    &lt;chr&gt;     &lt;chr&gt;       &lt;chr&gt; &lt;chr&gt;  &lt;chr&gt;
##  1 Norway  NOR         High in… 4300062   206532528   0.28… Male   52   
##  2 Gabon   GAB         Sub-Sah… 1269789   145744642   0.74… Male   18   
##  3 United… USA         High in… 261642064 207366667   1.10… Female 15   
##  4 Maurit… MRT         Sub-Sah… 2576113   114079731   0.68… Female 10   
##  5 Ireland IRL         High in… 3737161.5 159679927   1.35… Male   17   
##  6 Cambod… KHM         East As… 10814416  210261134   0.39… Female 61   
##  7 Saudi … SAU         High in… 24033932  188270882   0.64… Female 9    
##  8 Namibia NAM         Sub-Sah… 1564881   114102862   1.16… Male   10   
##  9 Tanzan… TZA         Sub-Sah… 30519122  197765577   1.91… Male   11   
## 10 Cambod… KHM         East As… 10814416  201585864   0.66… Female 22   
## # … with 15,482 more rows, and 24 more variables: educ &lt;chr&gt;, inc_q &lt;chr&gt;,
## #   emp_in &lt;chr&gt;, fin2 &lt;chr&gt;, fin7 &lt;chr&gt;, fin8 &lt;chr&gt;, fin14a &lt;chr&gt;,
## #   fin14b &lt;chr&gt;, fin19 &lt;chr&gt;, fin26 &lt;chr&gt;, fin28 &lt;chr&gt;, fin32 &lt;chr&gt;,
## #   fin37 &lt;chr&gt;, mobileowner &lt;chr&gt;, account_fin &lt;chr&gt;, account_mob &lt;chr&gt;,
## #   account &lt;chr&gt;, saved &lt;chr&gt;, borrowed &lt;chr&gt;, receive_wages &lt;chr&gt;,
## #   receive_transfers &lt;chr&gt;, receive_pension &lt;chr&gt;,
## #   receive_agriculture &lt;chr&gt;, fin2_b &lt;chr&gt;
```


---
## `_if()`

Example: `mutate_if()`


```r
findex %&gt;%
    transmute_if(.predicate=is.numeric, .funs = list(log=~log(.)
                                                  , abs=~abs(.)))
```

```
## # A tibble: 15,492 x 16
##    pop_adult_log wpid_random_log wgt_log age_log receive_transfe…
##            &lt;dbl&gt;           &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;            &lt;dbl&gt;
##  1          15.3            19.1  -1.27     3.95             0   
##  2          14.1            18.8  -0.288    2.89             1.39
##  3          19.4            19.1   0.103    2.71             0   
##  4          14.8            18.6  -0.382    2.30             1.39
##  5          15.1            18.9   0.304    2.83             1.10
##  6          16.2            19.2  -0.935    4.11             1.39
##  7          17.0            19.1  -0.445    2.20             1.39
##  8          14.3            18.6   0.156    2.30             1.39
##  9          17.2            19.1   0.651    2.40             1.39
## 10          16.2            19.1  -0.412    3.09             1.39
## # … with 15,482 more rows, and 11 more variables:
## #   receive_pension_log &lt;dbl&gt;, receive_agriculture_log &lt;dbl&gt;,
## #   fin2_b_log &lt;dbl&gt;, pop_adult_abs &lt;dbl&gt;, wpid_random_abs &lt;dbl&gt;,
## #   wgt_abs &lt;dbl&gt;, age_abs &lt;dbl&gt;, receive_transfers_abs &lt;dbl&gt;,
## #   receive_pension_abs &lt;dbl&gt;, receive_agriculture_abs &lt;dbl&gt;,
## #   fin2_b_abs &lt;dbl&gt;
```

---
## `_at()`

Example: `mutate_at()`


```r
findex %&gt;%
    transmute_at(.vars = vars(contains("fin")), .funs = ~case_when(
        .=="no" ~ 0
        , .=="yes" ~ 1
    ))
```

```
## # A tibble: 15,492 x 12
##     fin2  fin7  fin8 fin14a fin14b fin19 fin26 fin28 fin32 fin37
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1     1     1     1      1      1     1    NA    NA     0     1
##  2     1     0    NA      1      0     0     1     1     1     0
##  3     1     0    NA      1      1     0    NA    NA     1     1
##  4     0     0    NA      0      0     0     0     0     0     0
##  5     1     1     1      1      1     0    NA    NA     1     1
##  6     0     0    NA      0      0     0     0     1     0     0
##  7     0     0    NA      0      0     0    NA    NA     1     0
##  8     1     0    NA      0      0     0     1     1     1     0
##  9     0     0    NA      0      0     0     0     0     1     0
## 10     0     0    NA      0      0     0     0     1     0     0
## # … with 15,482 more rows, and 2 more variables: account_fin &lt;dbl&gt;,
## #   fin2_b &lt;dbl&gt;
```

---
## Merging data

.pl[
- Normally, one finds data distributed into several different files
- dplyr provides join functions to perform merging according to matching cells indetifiers
  &lt;!-- - `left_join()` --&gt;
  &lt;!-- - `right_join()` --&gt;
  &lt;!-- - `inner_join()` --&gt;
  &lt;!-- - `full_join()` --&gt;
  &lt;!-- - `anti_join()` --&gt;
  &lt;!-- - `semi_join()` --&gt;

&lt;img src="img/join2.png" width="50%" style="display: block; margin: auto;" /&gt;

  ]
  
.pr[
  
- Also it is possible to combine datasets when they share the same column names with `bind_cols()`

&lt;img src="img/join1.png" width="60%" style="display: block; margin: auto;" /&gt;

- Or rows with `bind_rows()`

&lt;img src="img/join3.png" width="40%" style="display: block; margin: auto;" /&gt;

]

---
## Merging data: example

.pl[

```r
(df1 &lt;- tibble::tribble(
    ~col1, ~col2, ~col3,
      "a",     1,     3,
      "b",    NA,     5,
      "b",     5,     6
    ))
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
(df2 &lt;- tibble::tribble(
           ~col1, ~col2, ~col4,
             "a",     1,  TRUE,
             "b",    NA, FALSE,
             "b",     6, FALSE,
             "c",    10, FALSE
           ))
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[

```r
(list_df &lt;- list(e1=df1, e2=df1, e3=df2))
```

```
## $e1
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
## 
## $e2
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
## 
## $e3
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```

]

---
## Merging data: left and right

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[


```r
# left_join(): matches values from df2 to df1
df1 %&gt;%
    left_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 3 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         5     6 NA
```


```r
# right_join(): matches valyes from df1 to df2
df1 %&gt;%
    right_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 4 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         6    NA FALSE
## 4 c        10    NA FALSE
```
]

---
## Merging data: inner and full

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[

```r
# inner_join(): retain only the rows with matches
df1 %&gt;%
    inner_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 2 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
```

```r
# full_join(): retain all values, all rows
df1 %&gt;%
    full_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 5 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         5     6 NA   
## 4 b         6    NA FALSE
## 5 c        10    NA FALSE
```
]

---
## Merging data: semi and anti

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]

.pr[

```r
# semi_join(): returns rows of df1 that have match in df2
df1 %&gt;%
    semi_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 2 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
```


```r
# anti_join(): return rows of df1 that do not have a match in df2
df1 %&gt;%
*   anti_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 1 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 b         5     6
```
]

---
## Merging data: by row/column

.pl[

```r
df1
```

```
## # A tibble: 3 x 3
##   col1   col2  col3
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3
## 2 b        NA     5
## 3 b         5     6
```

```r
df2
```

```
## # A tibble: 4 x 3
##   col1   col2 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1 TRUE 
## 2 b        NA FALSE
## 3 b         6 FALSE
## 4 c        10 FALSE
```
]


.pr[

```r
# bind_rows: When row-binding, columns are matched by name, 
# and any missing columns will be filled with NA.
df1 %&gt;%
    bind_rows(df2)
```

```
## # A tibble: 7 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 NA   
## 2 b        NA     5 NA   
## 3 b         5     6 NA   
## 4 a         1    NA TRUE 
## 5 b        NA    NA FALSE
## 6 b         6    NA FALSE
## 7 c        10    NA FALSE
```


```r
# bind_cols: rows are matched by position, 
# so all data frames must have the same number of rows.
df1 %&gt;%
    bind_cols(df1)
```

```
## # A tibble: 3 x 6
##   col1   col2  col3 col11 col21 col31
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1 a         1     3 a         1     3
## 2 b        NA     5 b        NA     5
## 3 b         5     6 b         5     6
```
]

---
## Merging data: advanced stuff


- Join functions have a `by=` argument to match specific columns.
- If two matching columns have different names one can specify such details by:


```r
data1 %&gt;%
    left_join(by = c("var1"="var2"))
```
--

.pl[
Notice the difference between:


```r
df1 %&gt;%
    left_join(df2)
```

```
## Joining, by = c("col1", "col2")
```

```
## # A tibble: 3 x 4
##   col1   col2  col3 col4 
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a         1     3 TRUE 
## 2 b        NA     5 FALSE
## 3 b         5     6 NA
```
]

.pr[
and...

```r
df1 %&gt;%
    left_join(df2, by="col1")
```

```
## # A tibble: 5 x 5
##   col1  col2.x  col3 col2.y col4 
##   &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;lgl&gt;
## 1 a          1     3      1 TRUE 
## 2 b         NA     5     NA FALSE
## 3 b         NA     5      6 FALSE
## 4 b          5     6     NA FALSE
## 5 b          5     6      6 FALSE
```
]

---
## Merging data: advanced stuff

.pl[
- What can we do if there are several separated datasets we want to:
    1. join?
    1. bind?
- According to the approach followed in the last slides it is necessary to call the join function per object, like:


```r
df1 %&gt;%
    left_join(df2) %&gt;%
    left_join(df3) %&gt;% ...
```

- However, there is a powerful and intuitive way to execute this task with the reduce function, which is also embedded in the package `purrr`. Therefore the problem could be solved only by specifying the list of dataframes and then applying the joining function recursively. Example:]

.pr[


```r
list(df1, df1, df2) %&gt;%
    reduce(.f = left_join, by="col1"
           , suffix=c("_iter1", "_iter2"))
```

```
## # A tibble: 9 x 7
##   col1  col2_iter1 col3_iter1 col2_iter2 col3_iter2  col2 col4 
##   &lt;chr&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt;      &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt;
## 1 a              1          3          1          3     1 TRUE 
## 2 b             NA          5         NA          5    NA FALSE
## 3 b             NA          5         NA          5     6 FALSE
## 4 b             NA          5          5          6    NA FALSE
## 5 b             NA          5          5          6     6 FALSE
## 6 b              5          6         NA          5    NA FALSE
## 7 b              5          6         NA          5     6 FALSE
## 8 b              5          6          5          6    NA FALSE
## 9 b              5          6          5          6     6 FALSE
```
]
---
# `tidyr`

- The main purpose of `tidyr` is to create tidy data
- There are 2 main functions for converting long to wide data and viceversa, plus other 2 useful for separating tasks.
    - `gather()`: takes multiple columns, and gathers them into key-value pairs: it makes “wide” data longer.
    - `spread()`: takes two columns (key &amp; value), and spreads into multiple columns: it makes “long” data wider.
    - `separate()`: pull apart columns that represent multiple variables
    - `extract()`: turns each group into a new column
    
---
### `gather()`

.pl[

```r
(df1 &lt;- df1 %&gt;%
    mutate(obs=1:3))
```

```
## # A tibble: 3 x 4
##   col1   col2  col3   obs
##   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt;
## 1 a         1     3     1
## 2 b        NA     5     2
## 3 b         5     6     3
```


```r
df1 %&gt;%
    gather(key = "key", value = "data")
```

```
## # A tibble: 12 x 2
##    key   data 
##    &lt;chr&gt; &lt;chr&gt;
##  1 col1  a    
##  2 col1  b    
##  3 col1  b    
##  4 col2  1    
##  5 col2  &lt;NA&gt; 
##  6 col2  5    
##  7 col3  3    
##  8 col3  5    
##  9 col3  6    
## 10 obs   1    
## 11 obs   2    
## 12 obs   3
```
]

.pr[

```r
(df1_long &lt;- df1 %&gt;%
    gather(key = "key", value = "data"
*          , -obs)
 )
```

```
## # A tibble: 9 x 3
##     obs key   data 
##   &lt;int&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 col1  a    
## 2     2 col1  b    
## 3     3 col1  b    
## 4     1 col2  1    
## 5     2 col2  &lt;NA&gt; 
## 6     3 col2  5    
## 7     1 col3  3    
## 8     2 col3  5    
## 9     3 col3  6
```
]

---
## `spread()`
.pl[

```r
(df1_long &lt;- df1_long %&gt;%
    mutate(new_var=paste0(data, "-", data)))
```

```
## # A tibble: 9 x 4
##     obs key   data  new_var
##   &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;  
## 1     1 col1  a     a-a    
## 2     2 col1  b     b-b    
## 3     3 col1  b     b-b    
## 4     1 col2  1     1-1    
## 5     2 col2  &lt;NA&gt;  NA-NA  
## 6     3 col2  5     5-5    
## 7     1 col3  3     3-3    
## 8     2 col3  5     5-5    
## 9     3 col3  6     6-6
```
]

.pr[

```r
df1_long %&gt;%
    spread(key = key, value = data)
```

```
## # A tibble: 9 x 5
##     obs new_var col1  col2  col3 
##   &lt;int&gt; &lt;chr&gt;   &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 1-1     &lt;NA&gt;  1     &lt;NA&gt; 
## 2     1 3-3     &lt;NA&gt;  &lt;NA&gt;  3    
## 3     1 a-a     a     &lt;NA&gt;  &lt;NA&gt; 
## 4     2 5-5     &lt;NA&gt;  &lt;NA&gt;  5    
## 5     2 b-b     b     &lt;NA&gt;  &lt;NA&gt; 
## 6     2 NA-NA   &lt;NA&gt;  &lt;NA&gt;  &lt;NA&gt; 
## 7     3 5-5     &lt;NA&gt;  5     &lt;NA&gt; 
## 8     3 6-6     &lt;NA&gt;  &lt;NA&gt;  6    
## 9     3 b-b     b     &lt;NA&gt;  &lt;NA&gt;
```
]

---
## `separate()`

.pl[

```r
df1_long %&gt;%
    separate(new_var, into = c("var1", "var2"), sep = "-")
```

```
## # A tibble: 9 x 5
##     obs key   data  var1  var2 
##   &lt;int&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt;
## 1     1 col1  a     a     a    
## 2     2 col1  b     b     b    
## 3     3 col1  b     b     b    
## 4     1 col2  1     1     1    
## 5     2 col2  &lt;NA&gt;  NA    NA   
## 6     3 col2  5     5     5    
## 7     1 col3  3     3     3    
## 8     2 col3  5     5     5    
## 9     3 col3  6     6     6
```
]

.pr[

```r
sv &lt;- tibble(id=1:3, q1=c("1", "1,2", "1,3,4"))
sv %&gt;%
    separate_rows(q1)
```

```
## # A tibble: 6 x 2
##      id q1   
##   &lt;int&gt; &lt;chr&gt;
## 1     1 1    
## 2     2 1    
## 3     2 2    
## 4     3 1    
## 5     3 3    
## 6     3 4
```
]

---
# `purrr`

.pl[
- Toolkit by providing a complete and consistent set of tools for working with functions and vectors.
- Allow you to replace many for loops with code that is both more succinct and easier to read.
- `purrr` has docenzs of functions, some could be overly complex. However, must of the time we will use the most basic function called `map()`
    - The `map_*()` functions transform their input by applying a function to each element and returning a vector the same length as the input.
    - `map()` is a powered `apply()`!


```r
lapply(X = letters[1:3], FUN = function(x) return(x))
```

```
## [[1]]
## [1] "a"
## 
## [[2]]
## [1] "b"
## 
## [[3]]
## [1] "c"
```
]

.pr[

```r
map(.x = letters[1:3], .f = function(x) return(x)) # explicit functions
```

```
## [[1]]
## [1] "a"
## 
## [[2]]
## [1] "b"
## 
## [[3]]
## [1] "c"
```

```r
map(.x = letters[1:3], .f = ~return(.)) # implicit functions
```

```
## [[1]]
## [1] "a"
## 
## [[2]]
## [1] "b"
## 
## [[3]]
## [1] "c"
```
]
---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
     group_by(economy, regionwb))
```

```
## # A tibble: 15,492 x 32
## # Groups:   economy, regionwb [144]
##    economy economycode regionwb pop_adult wpid_random   wgt female   age
##    &lt;chr&gt;   &lt;chr&gt;       &lt;chr&gt;        &lt;dbl&gt;       &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt;  &lt;dbl&gt;
##  1 Norway  NOR         High in…    4.30e6   206532528 0.282 Male      52
##  2 Gabon   GAB         Sub-Sah…    1.27e6   145744642 0.750 Male      18
##  3 United… USA         High in…    2.62e8   207366667 1.11  Female    15
##  4 Maurit… MRT         Sub-Sah…    2.58e6   114079731 0.682 Female    10
##  5 Ireland IRL         High in…    3.74e6   159679927 1.36  Male      17
##  6 Cambod… KHM         East As…    1.08e7   210261134 0.393 Female    61
##  7 Saudi … SAU         High in…    2.40e7   188270882 0.641 Female     9
##  8 Namibia NAM         Sub-Sah…    1.56e6   114102862 1.17  Male      10
##  9 Tanzan… TZA         Sub-Sah…    3.05e7   197765577 1.92  Male      11
## 10 Cambod… KHM         East As…    1.08e7   201585864 0.662 Female    22
## # … with 15,482 more rows, and 24 more variables: educ &lt;fct&gt;, inc_q &lt;fct&gt;,
## #   emp_in &lt;fct&gt;, fin2 &lt;fct&gt;, fin7 &lt;fct&gt;, fin8 &lt;fct&gt;, fin14a &lt;fct&gt;,
## #   fin14b &lt;fct&gt;, fin19 &lt;fct&gt;, fin26 &lt;fct&gt;, fin28 &lt;fct&gt;, fin32 &lt;fct&gt;,
## #   fin37 &lt;fct&gt;, mobileowner &lt;fct&gt;, account_fin &lt;fct&gt;, account_mob &lt;fct&gt;,
## #   account &lt;fct&gt;, saved &lt;fct&gt;, borrowed &lt;fct&gt;, receive_wages &lt;fct&gt;,
## #   receive_transfers &lt;dbl&gt;, receive_pension &lt;dbl&gt;,
## #   receive_agriculture &lt;dbl&gt;, fin2_b &lt;dbl&gt;
```

---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
     group_by(economy, regionwb) %&gt;% 
     nest() # take every peace of data associated with the group
 )
```

```
## # A tibble: 144 x 3
##    economy       regionwb                                 data             
##    &lt;chr&gt;         &lt;chr&gt;                                    &lt;list&gt;           
##  1 Norway        High income: OECD                        &lt;tibble [109 × 3…
##  2 Gabon         Sub-Saharan Africa (excluding high inco… &lt;tibble [101 × 3…
##  3 United States High income: OECD                        &lt;tibble [99 × 30…
##  4 Mauritania    Sub-Saharan Africa (excluding high inco… &lt;tibble [114 × 3…
##  5 Ireland       High income: OECD                        &lt;tibble [103 × 3…
##  6 Cambodia      East Asia &amp; Pacific (excluding high inc… &lt;tibble [162 × 3…
##  7 Saudi Arabia  High income: nonOECD                     &lt;tibble [113 × 3…
##  8 Namibia       Sub-Saharan Africa (excluding high inco… &lt;tibble [103 × 3…
##  9 Tanzania      Sub-Saharan Africa (excluding high inco… &lt;tibble [94 × 30…
## 10 Latvia        High income: OECD                        &lt;tibble [88 × 30…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
    group_nest(economy, regionwb) %&gt;% # Notice that there is a function that does the =
    mutate(model=map(data # loop over each element of the column data
                     , ~glm(fin2_b~pop_adult+female+age+educ # specification
                            , data = . # the dot is interpreted as every value of data
                            , family = binomial() # link function
                            )
                     )
           )
 )
```

```
## # A tibble: 144 x 4
##    economy    regionwb                              data            model  
##    &lt;chr&gt;      &lt;chr&gt;                                 &lt;list&gt;          &lt;list&gt; 
##  1 Afghanist… South Asia                            &lt;tibble [92 × … &lt;S3: g…
##  2 Albania    Europe &amp; Central Asia (excluding hig… &lt;tibble [115 ×… &lt;S3: g…
##  3 Algeria    Middle East &amp; North Africa (excludin… &lt;tibble [98 × … &lt;S3: g…
##  4 Argentina  Latin America &amp; Caribbean (excluding… &lt;tibble [96 × … &lt;S3: g…
##  5 Armenia    Europe &amp; Central Asia (excluding hig… &lt;tibble [104 ×… &lt;S3: g…
##  6 Australia  High income: OECD                     &lt;tibble [101 ×… &lt;S3: g…
##  7 Austria    High income: OECD                     &lt;tibble [108 ×… &lt;S3: g…
##  8 Azerbaijan Europe &amp; Central Asia (excluding hig… &lt;tibble [85 × … &lt;S3: g…
##  9 Bahrain    High income: nonOECD                  &lt;tibble [93 × … &lt;S3: g…
## 10 Bangladesh South Asia                            &lt;tibble [107 ×… &lt;S3: g…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power


```r
(findex_model &lt;- findex %&gt;%
    group_nest(economy, regionwb) %&gt;%
    mutate(model=map(data
                     , ~glm(fin2_b~female+age+educ
                            , data = .
                            , family = binomial()
                            )
                     )
           , coef=map(model, tidy) # coefficients as tibble
           , stats=map(model, glance) # summary statistics
           , fitted=map(model, augment) # adds info on each observation
           ) 
 )
```

```
## # A tibble: 144 x 7
##    economy   regionwb            data      model  coef    stats   fitted   
##    &lt;chr&gt;     &lt;chr&gt;               &lt;list&gt;    &lt;list&gt; &lt;list&gt;  &lt;list&gt;  &lt;list&gt;   
##  1 Afghanis… South Asia          &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  2 Albania   Europe &amp; Central A… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  3 Algeria   Middle East &amp; Nort… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  4 Argentina Latin America &amp; Ca… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  5 Armenia   Europe &amp; Central A… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  6 Australia High income: OECD   &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  7 Austria   High income: OECD   &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  8 Azerbaij… Europe &amp; Central A… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
##  9 Bahrain   High income: nonOE… &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
## 10 Banglade… South Asia          &lt;tibble … &lt;S3: … &lt;tibbl… &lt;tibbl… &lt;tibble …
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power


```r
findex_model$coef[[1]]
```

```
## # A tibble: 5 x 5
##   term                           estimate std.error  statistic p.value
##   &lt;chr&gt;                             &lt;dbl&gt;     &lt;dbl&gt;      &lt;dbl&gt;   &lt;dbl&gt;
## 1 (Intercept)                     -245.     110831. -0.00221     0.998
## 2 femaleFemale                      -3.22    54430. -0.0000591   1.000
## 3 age                                3.98     1808.  0.00220     0.998
## 4 educsecondary                     71.7     71401.  0.00100     0.999
## 5 educcompleted tertiary or more   186.      86496.  0.00215     0.998
```


---
# `purrr`: unleashing the true power

Let's extract the log odds gender==female

```r
(findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale")
                           )
           )
 )
```

```
## # A tibble: 144 x 8
##    economy  regionwb       data    model  coef   stats  fitted  female_coef
##    &lt;chr&gt;    &lt;chr&gt;          &lt;list&gt;  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;  &lt;list&gt;     
##  1 Afghani… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  2 Albania  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  3 Algeria  Middle East &amp;… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  4 Argenti… Latin America… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  5 Armenia  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  6 Austral… High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  7 Austria  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  8 Azerbai… Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  9 Bahrain  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## 10 Banglad… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## # … with 134 more rows
```


---
# `purrr`: unleashing the true power

Why not calculing confidence intervals? and extracting the relevant variables

```r
(findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale") %&gt;%
                            mutate(min_int=estimate-1.96*std.error
                                   , max_int=estimate+1.96*std.error) %&gt;% 
                            dplyr::select(estimate, p.value, contains("int")
                                          )
                           )
           )
 )
```

```
## # A tibble: 144 x 8
##    economy  regionwb       data    model  coef   stats  fitted  female_coef
##    &lt;chr&gt;    &lt;chr&gt;          &lt;list&gt;  &lt;list&gt; &lt;list&gt; &lt;list&gt; &lt;list&gt;  &lt;list&gt;     
##  1 Afghani… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  2 Albania  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  3 Algeria  Middle East &amp;… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  4 Argenti… Latin America… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  5 Armenia  Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  6 Austral… High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  7 Austria  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  8 Azerbai… Europe &amp; Cent… &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
##  9 Bahrain  High income: … &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## 10 Banglad… South Asia     &lt;tibbl… &lt;S3: … &lt;tibb… &lt;tibb… &lt;tibbl… &lt;tibble [1…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power

Let's get rid of the columns that we are not interested


```r
(findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale") %&gt;%
                            mutate(min_int=estimate-1.96*std.error
                                   , max_int=estimate+1.96*std.error) %&gt;% 
                            dplyr::select(estimate, p.value, contains("int")
                                          )
                           )
           ) %&gt;% 
     dplyr::select(economy, regionwb, female_coef)
 )
```

```
## # A tibble: 144 x 3
##    economy     regionwb                                     female_coef    
##    &lt;chr&gt;       &lt;chr&gt;                                        &lt;list&gt;         
##  1 Afghanistan South Asia                                   &lt;tibble [1 × 4…
##  2 Albania     Europe &amp; Central Asia (excluding high incom… &lt;tibble [1 × 4…
##  3 Algeria     Middle East &amp; North Africa (excluding high … &lt;tibble [1 × 4…
##  4 Argentina   Latin America &amp; Caribbean (excluding high i… &lt;tibble [1 × 4…
##  5 Armenia     Europe &amp; Central Asia (excluding high incom… &lt;tibble [1 × 4…
##  6 Australia   High income: OECD                            &lt;tibble [1 × 4…
##  7 Austria     High income: OECD                            &lt;tibble [1 × 4…
##  8 Azerbaijan  Europe &amp; Central Asia (excluding high incom… &lt;tibble [1 × 4…
##  9 Bahrain     High income: nonOECD                         &lt;tibble [1 × 4…
## 10 Bangladesh  South Asia                                   &lt;tibble [1 × 4…
## # … with 134 more rows
```

---
# `purrr`: unleashing the true power

What's inside female_coef?


```r
(findex_model &lt;- findex_model %&gt;%
    mutate(female_coef=map(coef, ~.x %&gt;%
                            dplyr::filter(term=="femaleFemale") %&gt;%
                            mutate(min_int=estimate-1.96*std.error
                                   , max_int=estimate+1.96*std.error) %&gt;% 
                            dplyr::select(estimate, p.value, contains("int")
                                          )
                           )
           ) %&gt;% 
     dplyr::select(economy, regionwb, female_coef) %&gt;% 
     unnest(female_coef)
 )
```

```
## # A tibble: 144 x 6
##    economy   regionwb                  estimate p.value   min_int   max_int
##    &lt;chr&gt;     &lt;chr&gt;                        &lt;dbl&gt;   &lt;dbl&gt;     &lt;dbl&gt;     &lt;dbl&gt;
##  1 Afghanis… South Asia                 -3.22   1.000    -1.07e+5   1.07e+5
##  2 Albania   Europe &amp; Central Asia (e…  -1.19   0.0466   -2.36e+0  -1.80e-2
##  3 Algeria   Middle East &amp; North Afri…  -1.99   0.00256  -3.28e+0  -6.95e-1
##  4 Argentina Latin America &amp; Caribbea…   0.502  0.261    -3.74e-1   1.38e+0
##  5 Armenia   Europe &amp; Central Asia (e…  -1.09   0.0300   -2.07e+0  -1.05e-1
##  6 Australia High income: OECD           0.0325 0.966    -1.45e+0   1.51e+0
##  7 Austria   High income: OECD          -0.913  0.118    -2.06e+0   2.31e-1
##  8 Azerbaij… Europe &amp; Central Asia (e…  -0.508  0.371    -1.62e+0   6.03e-1
##  9 Bahrain   High income: nonOECD       -1.65   0.00864  -2.89e+0  -4.19e-1
## 10 Banglade… South Asia                 -1.94   0.0822   -4.12e+0   2.47e-1
## # … with 134 more rows
```


---
# `purrr`: unleashing the true power

Little exploration maybe?


```r
findex_model %&gt;% summary()
```

```
##    economy            regionwb            estimate           p.value      
##  Length:144         Length:144         Min.   :-18.0594   Min.   :0.0000  
##  Class :character   Class :character   1st Qu.: -0.8269   1st Qu.:0.1419  
##  Mode  :character   Mode  :character   Median : -0.2921   Median :0.3908  
##                                        Mean   :  0.5553   Mean   :0.4400  
##                                        3rd Qu.:  0.2241   3rd Qu.:0.7081  
##                                        Max.   : 87.8917   Max.   :1.0000  
##     min_int              max_int         
##  Min.   :-106685.70   Min.   :    -0.85  
##  1st Qu.:     -2.20   1st Qu.:     0.29  
##  Median :     -1.61   Median :     0.89  
##  Mean   :  -1482.80   Mean   :  1483.91  
##  3rd Qu.:     -1.04   3rd Qu.:     1.50  
##  Max.   :     -0.14   Max.   :106679.26
```

---
# `purrr`: unleashing the true power

The natural question is "why", but for the sake of the exercise we are going to truncate the data and keep the record that lie between the 10% and 90% percentile of the lower confidence interval

```r
(findex_model_coef &lt;- findex_model %&gt;%
    filter_at(.vars = vars(min_int)
              , .vars_predicate = any_vars(between(., quantile(., 0.1)
                                                   , quantile(., 0.9)
                                                   )
                                           )
              ) )
```

```
## # A tibble: 114 x 6
##    economy   regionwb                      estimate p.value min_int max_int
##    &lt;chr&gt;     &lt;chr&gt;                            &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;   &lt;dbl&gt;
##  1 Albania   Europe &amp; Central Asia (exclu…  -1.19   0.0466    -2.36 -0.0180
##  2 Armenia   Europe &amp; Central Asia (exclu…  -1.09   0.0300    -2.07 -0.105 
##  3 Australia High income: OECD               0.0325 0.966     -1.45  1.51  
##  4 Austria   High income: OECD              -0.913  0.118     -2.06  0.231 
##  5 Azerbaij… Europe &amp; Central Asia (exclu…  -0.508  0.371     -1.62  0.603 
##  6 Bahrain   High income: nonOECD           -1.65   0.00864   -2.89 -0.419 
##  7 Belarus   Europe &amp; Central Asia (exclu…  -0.136  0.789     -1.13  0.859 
##  8 Benin     Sub-Saharan Africa (excludin…  -1.15   0.115     -2.59  0.281 
##  9 Bolivia   Latin America &amp; Caribbean (e…  -0.612  0.195     -1.54  0.314 
## 10 Botswana  Sub-Saharan Africa (excludin…  -1.09   0.0420    -2.13 -0.0393
## # … with 104 more rows
```

---
# `purrr`: unleashing the true power

.pl[

```r
g0 &lt;- findex_model_coef %&gt;% 
    qplot(min_int, geom = "density", data = ., ylab = "density")+
    scale_x_continuous(limits = c(-5, 0))
```
]

.pr[
![](ws_3_files/figure-html/unnamed-chunk-50-1.png)&lt;!-- --&gt;
]

---
# `purrr`: unleashing the true power

.pl[


```r
g1 &lt;- findex_model_coef %&gt;%
    filter(grepl(regionwb, pattern = "High")) %&gt;%
    ggplot() +
    geom_point(aes(economy, estimate, col=economy))+
    geom_linerange(aes(ymin=min_int, ymax=max_int, x=economy))+
    geom_hline(yintercept = 0, linetype="dotted", col="red")+
    coord_flip()+
    facet_wrap(~regionwb)
```
]

.pr[
![](ws_3_files/figure-html/unnamed-chunk-52-1.png)&lt;!-- --&gt;
]
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-dark",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
