<!DOCTYPE html>
<html>
  <head>
    <title>Workshop: Data science with R</title>
    <meta charset="utf-8">
    <meta name="author" content="Obryan Poyser" />
    <link rel="stylesheet" href="css/zew-fonts.css" type="text/css" />
    <link rel="stylesheet" href="css/zew.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Workshop: Data science with R
## ZEW - Session #2
### Obryan Poyser
### 2019/02/19

---




# Flow control

The simplest flow control is conditional execution `if` which takes a scalar and prompt a statements of if this value is `TRUE`.


```r
if(T==TRUE) print("This is tautological!")
```

```
## [1] "This is tautological!"
```


```r
if(T) print("Same as above, but implicitly")
```

```
## [1] "Same as above, but implicitly"
```


```r
if(FALSE==FALSE) print("Does it even worth mention it?")
```

```
## [1] "Does it even worth mention it?"
```


```r
if(FALSE) print("This is not going to be printed")
```


```r
if(5&lt;10) print("5 is less than 10")
```

```
## [1] "5 is less than 10"
```

Tip: For the sake of keeping good programming practices, it is recommented to employ curly brackets.
---

# Flow control

Conditional operations have little sense if there is no actions when the initial statement is not meet, is this case we are going to use `else`.


```r
x &lt;- 8
if(x&lt;=7){
  print("x is less equal than 7")
} else { # else MUST appear in the same line were the curly bracket closes
  print("x is more than 7")
}
```

```
## [1] "x is more than 7"
```

Certainly, more complex conditional operations can be created adding `if` after the `else`. For instance:


```r
if(x&lt;=7){
  print("x is less equal than 7")
} else if(x&lt;10) {
  print("x is more than 7 but less than 10")
} else {
  print("x is more than 10")
}
```

```
## [1] "x is more than 7 but less than 10"
```


---

# Flow control

The aforementioned statements only accept vectors of length zero, none the less, there are build-in functions that perform the same conditionals that can also be expanded to vectors. **Try it if you want**

The vectorized conditional function is `ifelse`, it is going to be truly useful is the future.


```r
x &lt;- 1:10
ifelse(test = x&lt;5, yes = "less than 5", no = "more equal than 5")
```

```
##  [1] "less than 5"       "less than 5"       "less than 5"      
##  [4] "less than 5"       "more equal than 5" "more equal than 5"
##  [7] "more equal than 5" "more equal than 5" "more equal than 5"
## [10] "more equal than 5"
```

---

# Loops

Loops are used in programming to perform a specific task recursively. In this section we will learn how to create loops in R.

- There are 3 types of loops in R: `repeat`, `while` and `for`.
- Normally, loops are initialized with a separated variables.
- Inside a loop a control variable is specified

---

## `for` loop

- The programmer controls how many times a loop is executed
- Composed by an *iterator* and a *sequence vector*
- Given the iterator


```r
x &lt;- letters[1:10]

for(i in 1:length(x)){
  print(x[i]=="g")
}
```

```
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] TRUE
## [1] FALSE
## [1] FALSE
## [1] FALSE
```

---

## `while` loop

.pl[
- `while` loops check first if a condition is met, if it does, executes, otherwise it does nothing.


```r
temperature &lt;- 10
while(temperature &lt; 18){
  print(paste0("If the temperature is "
               , temperature, " C°: Do not swim"))
  temperature=temperature+1
}
```

```
## [1] "If the temperature is 10 C°: Do not swim"
## [1] "If the temperature is 11 C°: Do not swim"
## [1] "If the temperature is 12 C°: Do not swim"
## [1] "If the temperature is 13 C°: Do not swim"
## [1] "If the temperature is 14 C°: Do not swim"
## [1] "If the temperature is 15 C°: Do not swim"
## [1] "If the temperature is 16 C°: Do not swim"
## [1] "If the temperature is 17 C°: Do not swim"
```

- The test expression `temperature &lt; 18` evaluates according the current vector's value.
- `while` loops have to include a incremental statement, falling to do so will create a...
]


--
.center[Infinite loop!]
&lt;img src="https://media.giphy.com/media/EmMWgjxt6HqXC/giphy.gif" style="display: block; margin: auto;" /&gt;

---

## `repeat` loop

- Executes the same code until the user stops it.
- Repeating an action infinite number of times is a nonsense, therefore `repeat` is oftenly used jointly with `stop`or `break`


```r
repeat{
  message("This won't stop!!") # It is not evaluated
}
```


```r
x &lt;- 1
repeat{
  print(x)
  x &lt;- x+1
  if(x==5){
    break
  }
}
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
```

---

# Loops+

- As might think, loops in are not limited to `repeat` `for` or, `while`.
- Advance loop functions let you apply a function to lists, matrices or vectors...
- `rep` and `replicate` represent the basic idea of functions applied to vectors.


```r
set.seed(123)
rep(x = rnorm(1), 7)
```

```
## [1] -0.5604756 -0.5604756 -0.5604756 -0.5604756 -0.5604756 -0.5604756
## [7] -0.5604756
```

```r
replicate(n = 7, expr = rnorm(1))
```

```
## [1] -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499  0.46091621
## [7] -1.26506123
```


---

# The `apply` family

- Part of base functions in R
- They use input lists and apply a function to each element.
- Family members differ in the type of object that stems from a execution.

.pl[
## `apply`
- Has 3 main arguments `X`, `MARGIN` and `FUN`
  - X is **matrix**
  - MARGIN refers to the orientation onto the functions has to be computed
    - 2 across **columns**
    - 1 across **rows**

```r
(mat &lt;- matrix(1:25, nrow = 5))
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    6   11   16   21
## [2,]    2    7   12   17   22
## [3,]    3    8   13   18   23
## [4,]    4    9   14   19   24
## [5,]    5   10   15   20   25
```
]

.pr[

```r
apply(X = mat, MARGIN = 1, FUN = sum)
```

```
## [1] 55 60 65 70 75
```

```r
apply(X = mat, MARGIN = 2, FUN = sum)
```

```
## [1]  15  40  65  90 115
```
]

---
## `lapply`

.pl[
- Permitted inputs: dataframes, lists or vectors.
- The outcome is a list (the *l* stands for something after all)


```r
set.seed(123)
list &lt;- list(e1=rnorm(100, 5, 1)
             , e2=rnorm(100, 10, 1)
             , e3=rnorm(100, 15, 1)
             , e4=list(rnorm(100, 5, 1)*100))
lapply(X = list, FUN = mean)
```

```
## Warning in mean.default(X[[i]], ...): argument is not numeric or logical:
## returning NA
```

```
## $e1
## [1] 5.090406
## 
## $e2
## [1] 9.892453
## 
## $e3
## [1] 15.12047
## 
## $e4
## [1] NA
```
]

.pr[

```r
lapply(X = list, FUN = function(x) mean(x[[1]]))
```

```
## $e1
## [1] 4.439524
## 
## $e2
## [1] 9.289593
## 
## $e3
## [1] 17.19881
## 
## $e4
## [1] 496.3777
```

What's happening above?
]

---
.pl[
## `sapply`

- A wrapper of `lapply`
- Tries to simplify the outcome of `lapply` if the argument *simplify* is set at `TRUE` (the default value)


```r
sapply(list, function(x) mean(x[[1]]))
```

```
##         e1         e2         e3         e4 
##   4.439524   9.289593  17.198810 496.377709
```

```r
sapply(list, function(x) mean(x[[1]]), simplify = F)
```

```
## $e1
## [1] 4.439524
## 
## $e2
## [1] 9.289593
## 
## $e3
## [1] 17.19881
## 
## $e4
## [1] 496.3777
```
]
.pr[
## `mapply`

- Multivariate apply
- Employ arguments and passes them into a function


```r
mapply(rnorm, n=1:5, mean=2, sd=1)
```

```
## [[1]]
## [1] 1.926444
## 
## [[2]]
## [1] 0.8313486 1.3652517
## 
## [[3]]
## [1] 1.9711584 2.6706960 0.3494535
## 
## [[4]]
## [1] 1.650246 2.756406 1.461191 2.227292
## 
## [[5]]
## [1] 2.492229 2.267835 2.653258 1.877291 1.586323
```
]

---
# Read and write

A preliminary for data analysis is: having data. Some datasets are "pretty", that is, they come in tabular format, a little cleaning and we are done. On the other side there are unstructured data, typically text-heavy files that demand a huge amount of time in order to be used as an input.

Have you ever heard of the quote "big rocks first", well, we will do the opposite here. Let's start by showing how to import, create and format tabular datasets.

## Base reading functions

The easiest form of data to import in R are *spreadsheet-like* text files.


```r
ls("package:base", pattern = "read")
```

```
## [1] "read.dcf"     "readBin"      "readChar"     "readline"    
## [5] "readLines"    "readRDS"      "readRenviron" "Sys.readlink"
```

```r
ls("package:utils", pattern = "read")
```

```
##  [1] "read.csv"         "read.csv2"        "read.delim"      
##  [4] "read.delim2"      "read.DIF"         "read.fortran"    
##  [7] "read.fwf"         "read.socket"      "read.table"      
## [10] "readCitationFile"
```


---
# Read and write

## `.txt` files

.pl[
Open a .txt files could easily become a Pandora's Box, you just never know if you are about to spread a misery in your work for days! 

![](https://media.giphy.com/media/5AVgmIw7iAzdK/giphy.gif)&lt;!-- --&gt;
]

.pr[
Problems:

- Missmatch decimal and thousand separators

| Locale                        | Format            |
|-------------------------------|-------------------|
| Canadian (English and French) | 4 294 967 295,000 |
| German                        | 4 294 967.295,000 |
| Italian                       | 4.294.967.295,000 |
| US-English                    | 4,294,967,295.00  |

- Ambigous column separators
  - Is it a Tab? Semicolon? Space? Comma?
]

---
# Import data
## `.txt` files

What we see:

&lt;img src="img/s2i1.png" width="70%" style="display: block; margin: auto;" /&gt;

What R sees:


```r
readLines(con = "datasets/sample.txt", n = 11)
```

```
## [1] "date\tiso_a3\tcurrency_code\tname\tlocal_price"
## [2] "4/1/2000\tARG\tARS\tArgentina\t2.5"            
## [3] "4/1/2000\tAUS\tAUD\tAustralia\t2.59"           
## [4] "4/1/2000\tBRA\tBRL\tBrazil\t2.95"              
## [5] "4/1/2000\tCAN\tCAD\tCanada\t2.85"              
## [6] "4/1/2000\tCHE\tCHF\tSwitzerland\t5.9"
```

---
# Import data
## `.txt` files


```r
read.table(file = "datasets/sample.txt", sep = "\t")
```

```
##         V1     V2            V3          V4          V5
## 1     date iso_a3 currency_code        name local_price
## 2 4/1/2000    ARG           ARS   Argentina         2.5
## 3 4/1/2000    AUS           AUD   Australia        2.59
## 4 4/1/2000    BRA           BRL      Brazil        2.95
## 5 4/1/2000    CAN           CAD      Canada        2.85
## 6 4/1/2000    CHE           CHF Switzerland         5.9
```

```r
read.delim(file = "datasets/sample.txt", sep = ".")
```

```
##                                    date.iso_a3.currency_code.name.local_price
## 4/1/2000\tARG\tARS\tArgentina\t2                                            5
## 4/1/2000\tAUS\tAUD\tAustralia\t2                                           59
## 4/1/2000\tBRA\tBRL\tBrazil\t2                                              95
## 4/1/2000\tCAN\tCAD\tCanada\t2                                              85
## 4/1/2000\tCHE\tCHF\tSwitzerland\t5                                          9
```

---
# Import data

.pl[
## `.csv` files

- CSV stands for Comma Separated Values
-  In practical terms .txt and .csv extensions aren't that different.
  - .csv extensions are composed by a delimiter and a enclosing (double quote to define a character), while .txt only have delimiter.
- `read.csv` formats character values as factors. This is inefficient since R has to map the values inside the vector a recognise how many different values exist within to form levels. Therefore, it is advisable to set `stringsAsFactors=FALSE`
]

.pr[
How to import a .csv to our environment?


```r
data &lt;- read.csv("datasets/big-mac-full-index.csv"
                 , stringsAsFactors = F)
str(data)
```

```
## 'data.frame':	1218 obs. of  19 variables:
##  $ date         : chr  "2000-04-01" "2000-04-01" "2000-04-01" "2000-04-01" ...
##  $ iso_a3       : chr  "ARG" "AUS" "BRA" "CAN" ...
##  $ currency_code: chr  "ARS" "AUD" "BRL" "CAD" ...
##  $ name         : chr  "Argentina" "Australia" "Brazil" "Canada" ...
##  $ local_price  : num  2.5 2.59 2.95 2.85 5.9 ...
##  $ dollar_ex    : num  1 1.68 1.79 1.47 1.7 ...
##  $ dollar_price : num  2.5 1.54 1.65 1.94 3.47 ...
##  $ USD_raw      : num  -0.004 -0.386 -0.343 -0.228 0.383 -0.023 -0.524 -0.446 0.226 -0.051 ...
##  $ EUR_raw      : num  0.05 -0.352 -0.308 -0.186 0.458 0.03 -0.498 -0.416 0.293 0 ...
##  $ GBP_raw      : num  -0.167 -0.486 -0.451 -0.354 0.156 -0.183 -0.602 -0.537 0.025 -0.207 ...
##  $ JPY_raw      : num  -0.099 -0.444 -0.406 -0.301 0.251 -0.116 -0.569 -0.499 0.11 -0.142 ...
##  $ CNY_raw      : num  1.091 0.289 0.378 0.622 1.903 ...
##  $ GDP_dollar   : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ adj_price    : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ USD_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ EUR_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ GBP_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ JPY_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ CNY_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
```
]

---
.pl[
# Import data from other statistical software

- R is an open source language, which is nice since you are free to use it, create and implement your own functionalities. Nonetheless, is also create inconsistencies (remember how different package can use a function with the same name?).
- There are several packages that convert between different extensions, the most popular are:
  - `foreign`: Reading and writing data stored by some versions of 'Epi Info', 'Minitab', 'S', 'SAS', 'SPSS', 'Stata', 'Systat', 'Weka', and for reading and writing some 'dBase' files.
  - `haven`: Import and Export 'SPSS', 'Stata' and 'SAS' Files
  - The difference stems in that outcome type and the speed
]
--
.pr[
## Import from SPSS


```r
survey &lt;- foreign::read.spss("datasets/survey.sav"
                             , to.data.frame = T)
```

```
## re-encoding from CP1252
```

```r
dim(survey)
```

```
## [1] 439 134
```

- Regularly SPSS files contain both a variable name and a description of such variable. When we read a SPSS file in R the labels disappear, and only the variables names are kept (labels can also be used, nonetheless they are most of the time big enough to not serve as a practical column name).
- R saves label (or description) as an attributes. Last session we learned that attributes can be extract with the function guess what? `attributes()`


```r
head(attributes(survey)$variable.labels)
```

```
##                       id                      sex                      age 
##                       ""                    "sex"                       "" 
##                  marital                    child                     educ 
##         "marital status"                  "child" "highest educ completed"
```
]

---
## Import from other statistical systems

- `Haven` is extremely useful since it follows the *Tidy* philosophy that is taking place in R. (we will cover this in depth the next session)

.pl[

```r
(money &lt;- foreign::read.dta("datasets/money.dta"))
```

```
##         y     m      i
## 1   506.5 141.8  3.247
## 2   524.6 146.5  2.605
## 3   565.0 149.2  2.908
## 4   596.7 154.7  3.253
## 5   637.7 161.8  3.686
## 6   691.1 169.5  4.055
## 7   756.0 173.7  5.082
## 8   799.6 185.1  4.630
## 9   873.4 199.4  5.470
## 10  944.0 205.8  6.853
## 11  992.7 216.5  6.562
## 12 1077.6 230.7  4.511
## 13 1185.9 251.9  4.466
## 14 1326.4 265.8  7.178
## 15 1434.2 277.5  7.926
## 16 1549.2 291.1  6.122
## 17 1718.0 310.4  5.266
## 18 1918.3 335.5  5.510
## 19 2163.9 363.2  7.572
## 20 2417.8 389.0 10.017
## 21 2631.7 414.1 11.374
## 22 2954.1 440.6 13.776
## 23 3073.0 478.2 11.084
## 24 3309.5 521.1  8.750
```
]

.pr[

```r
(money &lt;- haven::read_dta("datasets/money.dta"))
```

```
## # A tibble: 24 x 3
##        y     m     i
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  506.  142.  3.25
##  2  525.  146.  2.61
##  3  565   149.  2.91
##  4  597.  155.  3.25
##  5  638.  162.  3.69
##  6  691.  170.  4.05
##  7  756   174.  5.08
##  8  800.  185.  4.63
##  9  873.  199.  5.47
## 10  944   206.  6.85
## # … with 14 more rows
```

Do you see any difference?

&lt;img src="https://media.giphy.com/media/NS7gPxeumewkWDOIxi/giphy.gif" width="25%" /&gt;
]

---
# Exporting

- Exporting data in R is not different from Reading it
- Normally, exporting functions start with `write*`. For instance:


```r
haven::write_dta(data = head(survey), path = "datasets/survey.dta")
```

- Make sure that the output has the features you expected!


```r
export_obj &lt;- survey[1:5, 1:3]
```



```r
write.csv(x = export_obj, file = "datasets/sample1.csv")
write.csv2(x = export_obj, file = "datasets/sample2.csv")
```

Are sample1 and sample2 equal? Let's see

```r
readLines(con = "datasets/sample1.csv", n = 2)
```

```
## [1] "\"\",\"id\",\"sex\",\"age\"" "\"1\",415,\"FEMALES\",24"
```

```r
readLines(con = "datasets/sample2.csv", n = 2)
```

```
## [1] "\"\";\"id\";\"sex\";\"age\"" "\"1\";415;\"FEMALES\";24"
```
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-dark",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
