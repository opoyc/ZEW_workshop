<!DOCTYPE html>
<html>
  <head>
    <title>Workshop: Data science with R</title>
    <meta charset="utf-8">
    <meta name="author" content="Obryan Poyser" />
    <link rel="stylesheet" href="css/zew-fonts.css" type="text/css" />
    <link rel="stylesheet" href="css/zew.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Workshop: Data science with R
## ZEW - Session #2
### Obryan Poyser
### 2019/02/19

---




# Today's outline

.middle[
1. Flow control
  1. if, else, ifelse
1. Loops
  1. for, while, repeat
  1. Advanced loops: the apply family
      1. lapply
      1. sapply
      1. mapply
1. Input/output
  1. Reading data
  1. Writing data
  ]

---

class: middle, inverse, center

# Flow control and loops

---


# Flow control

The simplest flow control is conditional execution `if` which takes a scalar and prompt a statements of if this value is `TRUE`.


```r
if(T==TRUE) print("This is tautological!")
```

```
## [1] "This is tautological!"
```


```r
if(T) print("Same as above, but implicitly")
```

```
## [1] "Same as above, but implicitly"
```


```r
if(FALSE==FALSE) print("Does it even worth mention it?")
```

```
## [1] "Does it even worth mention it?"
```


```r
if(FALSE) print("This is not going to be printed")
```


```r
if(5&lt;10) print("5 is less than 10")
```

```
## [1] "5 is less than 10"
```

Tip: For the sake of keeping good programming practices, it is recommented to employ curly brackets.
---

# Flow control

Conditional operations have little sense if there is no actions when the initial statement is not meet, is this case we are going to use `else`.


```r
x &lt;- 8
if(x&lt;=7){
  print("x is less equal than 7")
} else { # else MUST appear in the same line were the curly bracket closes
  print("x is more than 7")
}
```

```
## [1] "x is more than 7"
```

Certainly, more complex conditional operations can be created adding `if` after the `else`. For instance:


```r
if(x&lt;=7){
  print("x is less equal than 7")
} else if(x&lt;10) {
  print("x is more than 7 but less than 10")
} else {
  print("x is more than 10")
}
```

```
## [1] "x is more than 7 but less than 10"
```


---

# Flow control

The aforementioned statements only accept vectors of length zero, none the less, there are build-in functions that perform the same conditionals that can also be expanded to vectors. **Try it if you want**

The vectorized conditional function is `ifelse`, it is going to be truly useful is the future.


```r
x &lt;- 1:10
ifelse(test = x&lt;5, yes = "less than 5", no = "more equal than 5")
```

```
##  [1] "less than 5"       "less than 5"       "less than 5"      
##  [4] "less than 5"       "more equal than 5" "more equal than 5"
##  [7] "more equal than 5" "more equal than 5" "more equal than 5"
## [10] "more equal than 5"
```

---

# Loops

Loops are used in programming to perform a specific task recursively. In this section we will learn how to create loops in R.

- There are 3 types of loops in R: `repeat`, `while` and `for`.
- Normally, loops are initialized with a separated variables.
- Inside a loop a control variable is specified

---

## `for` loop

- The programmer controls how many times a loop is executed
- Composed by an *iterator* and a *sequence vector*
- Given the iterator


```r
x &lt;- letters[1:10]

for(i in 1:length(x)){
  print(x[i]=="g")
}
```

```
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] FALSE
## [1] TRUE
## [1] FALSE
## [1] FALSE
## [1] FALSE
```

---

## `while` loop

.pl[
- `while` loops check first if a condition is met, if it does, executes, otherwise it does nothing.


```r
temperature &lt;- 10
while(temperature &lt; 18){
  print(paste0("If the temperature is "
               , temperature, " C°: Do not swim"))
  temperature=temperature+1
}
```

```
## [1] "If the temperature is 10 C°: Do not swim"
## [1] "If the temperature is 11 C°: Do not swim"
## [1] "If the temperature is 12 C°: Do not swim"
## [1] "If the temperature is 13 C°: Do not swim"
## [1] "If the temperature is 14 C°: Do not swim"
## [1] "If the temperature is 15 C°: Do not swim"
## [1] "If the temperature is 16 C°: Do not swim"
## [1] "If the temperature is 17 C°: Do not swim"
```

- The test expression `temperature &lt; 18` evaluates according the current vector's value.
- `while` loops have to include a incremental statement, falling to do so will create a...
]


--
.center[Infinite loop!]
&lt;img src="https://media.giphy.com/media/EmMWgjxt6HqXC/giphy.gif" style="display: block; margin: auto;" /&gt;

---

## `repeat` loop

- Executes the same code until the user stops it.
- Repeating an action infinite number of times is a nonsense, therefore `repeat` is oftenly used jointly with `stop`or `break`


```r
repeat{
  message("This won't stop!!") # It is not evaluated
}
```


```r
x &lt;- 1
repeat{
  print(x)
  x &lt;- x+1
  if(x==5){
    break
  }
}
```

```
## [1] 1
## [1] 2
## [1] 3
## [1] 4
```

---

# Loops+

- As might think, loops in are not limited to `repeat` `for` or, `while`.
- Advance loop functions let you apply a function to lists, matrices or vectors...
- `rep` and `replicate` represent the basic idea of functions applied to vectors.


```r
set.seed(123)
rep(x = rnorm(1), 7)
```

```
## [1] -0.5604756 -0.5604756 -0.5604756 -0.5604756 -0.5604756 -0.5604756
## [7] -0.5604756
```

```r
replicate(n = 7, expr = rnorm(1))
```

```
## [1] -0.23017749  1.55870831  0.07050839  0.12928774  1.71506499  0.46091621
## [7] -1.26506123
```


---

# The `apply` family

- Part of base functions in R
- They use input lists and apply a function to each element.
- Family members differ in the type of object that stems from a execution.

.pl[
## `apply`
- Has 3 main arguments `X`, `MARGIN` and `FUN`
  - X is **matrix**
  - MARGIN refers to the orientation onto the functions has to be computed
    - 2 across **columns**
    - 1 across **rows**

```r
(mat &lt;- matrix(1:25, nrow = 5))
```

```
##      [,1] [,2] [,3] [,4] [,5]
## [1,]    1    6   11   16   21
## [2,]    2    7   12   17   22
## [3,]    3    8   13   18   23
## [4,]    4    9   14   19   24
## [5,]    5   10   15   20   25
```
]

.pr[

```r
apply(X = mat, MARGIN = 1, FUN = sum)
```

```
## [1] 55 60 65 70 75
```

```r
apply(X = mat, MARGIN = 2, FUN = sum)
```

```
## [1]  15  40  65  90 115
```
]

---
## `lapply`

.pl[
- Permitted inputs: dataframes, lists or vectors.
- The outcome is a list (the *l* stands for something after all)


```r
set.seed(123)
list &lt;- list(e1=rnorm(100, 5, 1)
             , e2=rnorm(100, 10, 1)
             , e3=rnorm(100, 15, 1)
             , e4=list(rnorm(100, 5, 1)*100))
lapply(X = list, FUN = mean)
```

```
## Warning in mean.default(X[[i]], ...): argument is not numeric or logical:
## returning NA
```

```
## $e1
## [1] 5.090406
## 
## $e2
## [1] 9.892453
## 
## $e3
## [1] 15.12047
## 
## $e4
## [1] NA
```
]

.pr[

```r
lapply(X = list, FUN = function(x) mean(x[[1]]))
```

```
## $e1
## [1] 4.439524
## 
## $e2
## [1] 9.289593
## 
## $e3
## [1] 17.19881
## 
## $e4
## [1] 496.3777
```

What's happening above?
]

---
.pl[
## `sapply`

- A wrapper of `lapply`
- Tries to simplify the outcome of `lapply` if the argument *simplify* is set at `TRUE` (the default value)


```r
sapply(list, function(x) mean(x[[1]]))
```

```
##         e1         e2         e3         e4 
##   4.439524   9.289593  17.198810 496.377709
```

```r
sapply(list, function(x) mean(x[[1]]), simplify = F)
```

```
## $e1
## [1] 4.439524
## 
## $e2
## [1] 9.289593
## 
## $e3
## [1] 17.19881
## 
## $e4
## [1] 496.3777
```
]
.pr[
## `mapply`

- Multivariate apply
- Employ arguments and passes them into a function


```r
mapply(rnorm, n=1:5, mean=2, sd=1)
```

```
## [[1]]
## [1] 1.926444
## 
## [[2]]
## [1] 0.8313486 1.3652517
## 
## [[3]]
## [1] 1.9711584 2.6706960 0.3494535
## 
## [[4]]
## [1] 1.650246 2.756406 1.461191 2.227292
## 
## [[5]]
## [1] 2.492229 2.267835 2.653258 1.877291 1.586323
```
]

---
class: inverse, middle, center

# Input/output

---
# Read and write

A preliminary for data analysis is: having data. Some datasets are "pretty", that is, they come in tabular format, a little cleaning and we are done. On the other side there are unstructured data, typically text-heavy files that demand a huge amount of time in order to be used as an input.

Have you ever heard of the quote "big rocks first", well, we will do the opposite here. Let's start by showing how to import, create and format tabular datasets.

## Base reading functions

The easiest form of data to import in R are *spreadsheet-like* text files.


```r
ls("package:base", pattern = "read")
```

```
## [1] "read.dcf"     "readBin"      "readChar"     "readline"    
## [5] "readLines"    "readRDS"      "readRenviron" "Sys.readlink"
```

```r
ls("package:utils", pattern = "read")
```

```
##  [1] "read.csv"         "read.csv2"        "read.delim"      
##  [4] "read.delim2"      "read.DIF"         "read.fortran"    
##  [7] "read.fwf"         "read.socket"      "read.table"      
## [10] "readCitationFile"
```


---
# Read and write

## `.txt` files

.pl[
Open a .txt files could easily become a Pandora's Box, you just never know if you are about to spread a misery in your work for days! 

![](https://media.giphy.com/media/5AVgmIw7iAzdK/giphy.gif)&lt;!-- --&gt;
]

.pr[
Problems:

- Missmatch decimal and thousand separators

| Locale                        | Format            |
|-------------------------------|-------------------|
| Canadian (English and French) | 4 294 967 295,000 |
| German                        | 4 294 967.295,000 |
| Italian                       | 4.294.967.295,000 |
| US-English                    | 4,294,967,295.00  |

- Ambigous column separators
  - Is it a Tab? Semicolon? Space? Comma?
]

---
# Import data
## `.txt` files

What we see:

&lt;img src="img/s2i1.png" width="70%" style="display: block; margin: auto;" /&gt;

What R sees:


```r
readLines(con = "datasets/sample.txt", n = 11)
```

```
## [1] "date\tiso_a3\tcurrency_code\tname\tlocal_price"
## [2] "4/1/2000\tARG\tARS\tArgentina\t2.5"            
## [3] "4/1/2000\tAUS\tAUD\tAustralia\t2.59"           
## [4] "4/1/2000\tBRA\tBRL\tBrazil\t2.95"              
## [5] "4/1/2000\tCAN\tCAD\tCanada\t2.85"              
## [6] "4/1/2000\tCHE\tCHF\tSwitzerland\t5.9"
```

---
# Import data
## `.txt` files


```r
read.table(file = "datasets/sample.txt", sep = "\t")
```

```
##         V1     V2            V3          V4          V5
## 1     date iso_a3 currency_code        name local_price
## 2 4/1/2000    ARG           ARS   Argentina         2.5
## 3 4/1/2000    AUS           AUD   Australia        2.59
## 4 4/1/2000    BRA           BRL      Brazil        2.95
## 5 4/1/2000    CAN           CAD      Canada        2.85
## 6 4/1/2000    CHE           CHF Switzerland         5.9
```

```r
read.delim(file = "datasets/sample.txt", sep = ".")
```

```
##                                    date.iso_a3.currency_code.name.local_price
## 4/1/2000\tARG\tARS\tArgentina\t2                                            5
## 4/1/2000\tAUS\tAUD\tAustralia\t2                                           59
## 4/1/2000\tBRA\tBRL\tBrazil\t2                                              95
## 4/1/2000\tCAN\tCAD\tCanada\t2                                              85
## 4/1/2000\tCHE\tCHF\tSwitzerland\t5                                          9
```

---
# Import data

.pl[
## `.csv` files

- CSV stands for Comma Separated Values
-  In practical terms .txt and .csv extensions aren't that different.
  - .csv extensions are composed by a delimiter and a enclosing (double quote to define a character), while .txt only have delimiter.
- `read.csv` formats character values as factors. This is inefficient since R has to map the values inside the vector a recognise how many different values exist within to form levels. Therefore, it is advisable to set `stringsAsFactors=FALSE`
]

.pr[
How to import a .csv to our environment?


```r
data &lt;- read.csv("datasets/big-mac-full-index.csv"
                 , stringsAsFactors = F)
str(data)
```

```
## 'data.frame':	1218 obs. of  19 variables:
##  $ date         : chr  "2000-04-01" "2000-04-01" "2000-04-01" "2000-04-01" ...
##  $ iso_a3       : chr  "ARG" "AUS" "BRA" "CAN" ...
##  $ currency_code: chr  "ARS" "AUD" "BRL" "CAD" ...
##  $ name         : chr  "Argentina" "Australia" "Brazil" "Canada" ...
##  $ local_price  : num  2.5 2.59 2.95 2.85 5.9 ...
##  $ dollar_ex    : num  1 1.68 1.79 1.47 1.7 ...
##  $ dollar_price : num  2.5 1.54 1.65 1.94 3.47 ...
##  $ USD_raw      : num  -0.004 -0.386 -0.343 -0.228 0.383 -0.023 -0.524 -0.446 0.226 -0.051 ...
##  $ EUR_raw      : num  0.05 -0.352 -0.308 -0.186 0.458 0.03 -0.498 -0.416 0.293 0 ...
##  $ GBP_raw      : num  -0.167 -0.486 -0.451 -0.354 0.156 -0.183 -0.602 -0.537 0.025 -0.207 ...
##  $ JPY_raw      : num  -0.099 -0.444 -0.406 -0.301 0.251 -0.116 -0.569 -0.499 0.11 -0.142 ...
##  $ CNY_raw      : num  1.091 0.289 0.378 0.622 1.903 ...
##  $ GDP_dollar   : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ adj_price    : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ USD_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ EUR_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ GBP_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ JPY_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
##  $ CNY_adjusted : num  NA NA NA NA NA NA NA NA NA NA ...
```
]

---
.pl[
# Import data from other statistical software

- R is an open source language, which is nice since you are free to use it, create and implement your own functionalities. Nonetheless, is also create inconsistencies (remember how different package can use a function with the same name?).
- There are several packages that convert between different extensions, the most popular are:
  - `foreign`: Reading and writing data stored by some versions of 'Epi Info', 'Minitab', 'S', 'SAS', 'SPSS', 'Stata', 'Systat', 'Weka', and for reading and writing some 'dBase' files.
  - `haven`: Import and Export 'SPSS', 'Stata' and 'SAS' Files
  - The difference stems in that outcome type and the speed
]
--
.pr[
## Import from SPSS


```r
survey &lt;- foreign::read.spss("datasets/survey.sav"
                             , to.data.frame = T)
```

```
## re-encoding from CP1252
```

```r
dim(survey)
```

```
## [1] 439 134
```

- Regularly SPSS files contain both a variable name and a description of such variable. When we read a SPSS file in R the labels disappear, and only the variables names are kept (labels can also be used, nonetheless they are most of the time big enough to not serve as a practical column name).
- R saves label (or description) as an attributes. Last session we learned that attributes can be extract with the function guess what? `attributes()`


```r
head(attributes(survey)$variable.labels)
```

```
##                       id                      sex                      age 
##                       ""                    "sex"                       "" 
##                  marital                    child                     educ 
##         "marital status"                  "child" "highest educ completed"
```
]

---
## Import from other statistical systems

- `Haven` is extremely useful since it follows the *Tidy* philosophy that is taking place in R. (we will cover this in depth the next session)

.pl[

```r
(money &lt;- foreign::read.dta("datasets/money.dta"))
```

```
##         y     m      i
## 1   506.5 141.8  3.247
## 2   524.6 146.5  2.605
## 3   565.0 149.2  2.908
## 4   596.7 154.7  3.253
## 5   637.7 161.8  3.686
## 6   691.1 169.5  4.055
## 7   756.0 173.7  5.082
## 8   799.6 185.1  4.630
## 9   873.4 199.4  5.470
## 10  944.0 205.8  6.853
## 11  992.7 216.5  6.562
## 12 1077.6 230.7  4.511
## 13 1185.9 251.9  4.466
## 14 1326.4 265.8  7.178
## 15 1434.2 277.5  7.926
## 16 1549.2 291.1  6.122
## 17 1718.0 310.4  5.266
## 18 1918.3 335.5  5.510
## 19 2163.9 363.2  7.572
## 20 2417.8 389.0 10.017
## 21 2631.7 414.1 11.374
## 22 2954.1 440.6 13.776
## 23 3073.0 478.2 11.084
## 24 3309.5 521.1  8.750
```
]

.pr[

```r
(money &lt;- haven::read_dta("datasets/money.dta"))
```

```
## # A tibble: 24 x 3
##        y     m     i
##    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1  506.  142.  3.25
##  2  525.  146.  2.61
##  3  565   149.  2.91
##  4  597.  155.  3.25
##  5  638.  162.  3.69
##  6  691.  170.  4.05
##  7  756   174.  5.08
##  8  800.  185.  4.63
##  9  873.  199.  5.47
## 10  944   206.  6.85
## # … with 14 more rows
```

Do you see any difference?

&lt;img src="https://media.giphy.com/media/NS7gPxeumewkWDOIxi/giphy.gif" width="25%" /&gt;
]

---
# Exporting

- Exporting data in R is not different from Reading it
- Normally, exporting functions start with `write*`. For instance:


```r
haven::write_dta(data = head(survey), path = "datasets/survey.dta")
```

- Make sure that the output has the features you expected!


```r
export_obj &lt;- survey[1:5, 1:3]
```



```r
write.csv(x = export_obj, file = "datasets/sample1.csv")
write.csv2(x = export_obj, file = "datasets/sample2.csv")
```

Are sample1 and sample2 equal? Let's see

```r
readLines(con = "datasets/sample1.csv", n = 2)
```

```
## [1] "\"\",\"id\",\"sex\",\"age\"" "\"1\",415,\"FEMALES\",24"
```

```r
readLines(con = "datasets/sample2.csv", n = 2)
```

```
## [1] "\"\";\"id\";\"sex\";\"age\"" "\"1\";415;\"FEMALES\";24"
```

---
# Saving into R data format

.pl[
## RDS

- Saves and reload **one** object to a file

Write:

```r
saveRDS(object = object, file = "file.rds")
```
Read:

```r
readRDS(file = "file.rds")
```
]
.pr[
## RData

- Saves one or more R objects

Write:

```r
save(list = list_objects, file = "file.RData")
```

Read:

```r
load(file = "file.RData")
```
]


---
class: inverse, middle, center

# Tidy Data and the Tidyverse

&lt;img src="img/hex-tidyverse.png" width="25%" /&gt;

---
# Tidy data

- Wordly wisdom dictates that 80% of data analysis is spent in wrangling procedures.
- Data preparation is a recursive task
  - One does not simply keep with a final dataset, updating and transforming data is oftenly unavoidable.
  - Searching from anomalous data points
  - Sanity checks
  - Missing values imputation, etc.
- Tidy data provide a standard way to explore, organize and analyze data.

&lt;div class="figure" style="text-align: center"&gt;
&lt;img src="img/s2i2.png" alt="Data analysis workflow (source: Wickham &amp;amp; Garret, 2017)" width="505" /&gt;
&lt;p class="caption"&gt;Data analysis workflow (source: Wickham &amp; Garret, 2017)&lt;/p&gt;
&lt;/div&gt;

Related packages (not covered):

- `data.table`: Fast aggregation of large data, fast ordered joins, fast add/modify/delete of columns by group using no copies at all, list columns, friendly and fast character-separated-value read/write. Offers a natural and flexible syntax, for faster development.


---
# Tidy data

.pl[
- Most datasets are organized into columns and rows
- Columns are oftenly labeled, not in the case of rows (is more common in time series data)
- There are many ways to structure the same underlying data

&amp;nbsp;

Structure #1

```
##      name treatment_a treatment_b
## 1 rebecca           1           2
## 2  thomas           3           6
## 3   janna           4           8
```

Structure #2


```
##             rebecca thomas janna
## treatment_a       1      3     4
## treatment_b       2      6     8
```
]

.pr[
### Principles

1. Each variable forms a column
1. Each observation forms a row
1. Each type of observational unit forms a table

&amp;nbsp;

Tidy structure


```
##      name   treatment result
## 1 rebecca treatment_a      1
## 2  thomas treatment_a      3
## 3   janna treatment_a      4
## 4 rebecca treatment_b      2
## 5  thomas treatment_b      6
## 6   janna treatment_b      8
```
]

---
# Tidy data

.pl[
- Tidy data is standard and makes it easy to extract variables
- Messy data regularly is described by:
  - Column headers are values, not variable names
  - Multiple variables are stored in one column.
  - Variables are stored in both rows and columns.
  - Multiple types of observational units are stored in the same table.
  - A single observational unit is stored in multiple tables.

- Solution?
  - Must messy datasets' problems can be solved by:
      - Melting
      - String splitting
      - Casting
]

.pr[
First things first...


```r
install.packages("tidyverse")
```

- Tidyverse is a set of packages that were designed to work together
- In this workshop we will follow this philosophy instead the base R functions
  - Why? Is more efficient and consistent
  - Old methods can be learnt "on-the-fly"
]

---
# Pipes

- In R one can apply succesive functions by enclosing between parentheses.
- Let's say we want to created a new variable inside the survey object (the one from the SPSS file), and get it's mean. This new variable is `\(age^2\)`


```r
x &lt;- survey$age # New intermediary variable
age_2 &lt;- x^2 # Apply the function
(mean_2 &lt;- mean(age_2)) # Calculate the mean of squared age
```

```
## [1] 1575.465
```

Evidently, one could also use the following process

```r
(mean_2 &lt;- mean((survey$age)^2))
```

```
## [1] 1575.465
```
 
Cleaner, isn't it? But, can you believe that there is a way to this more consistent and readable?

```r
# The basic pipe `%&gt;%` works as:
y %&gt;%
  f() %&gt;%  = g(f(y))
  g()
```

---
# Pipes

So, if we want to get the mean value of the squared age:


```r
survey$age %&gt;%
  .^2 %&gt;%
  mean()
```

```
## [1] 1575.465
```

--

- `matrittr` allow us to create a more readable code
  - Structuring sequences of data operations left-to-right (as opposed to from the inside and out)
  - avoiding nested function calls,
  - minimizing the need for local variables and function definitions, and
  - making it easy to add steps anywhere in the sequence of operations.

Basic pipes

```
- x %&gt;% f is equivalent to f(x)
- x %&gt;% f(y) is equivalent to f(x, y)
- x %&gt;% f %&gt;% g %&gt;% h is equivalent to h(g(f(x)))
```

Placeholder
```
- x %&gt;% f(y, .) is equivalent to f(y, x)
- x %&gt;% f(y, z = .) is equivalent to f(y, z = x)
```


---
# Tibbles

- tibbles are data.frames with steroids
- Almost all functions in the Tidyverse creates a tibble
- It never changes the type of the inputs (i.e. string to factor)
- Nor the names of variables
- tibbles also have an enhanced print() method which makes them easier to use with large datasets containing complex objects.


```r
(survey_2 &lt;- as_tibble(survey[1:100
                            , c("sex", "age", "educ", "mast1")]
                     )
 ) # Let's create a sample of survey from the SPSS file
```

```
## # A tibble: 100 x 4
##    sex       age educ                     mast1
##    &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;                    &lt;dbl&gt;
##  1 FEMALES    24 COMPLETED UNDERGRADUATE      2
##  2 MALES      39 COMPLETED UNDERGRADUATE      2
##  3 FEMALES    48 SOME SECONDARY               3
##  4 MALES      41 SOME SECONDARY               2
##  5 MALES      23 COMPLETED UNDERGRADUATE      1
##  6 FEMALES    31 COMPLETED UNDERGRADUATE      1
##  7 FEMALES    30 SOME ADDITIONAL TRAINING     4
##  8 MALES      23 COMPLETED UNDERGRADUATE      2
##  9 FEMALES    18 SOME SECONDARY               3
## 10 MALES      23 POSTGRADUATE COMPLETED       3
## # … with 90 more rows
```


---
# Dplyr

- My favorite package, by far!
- Establish a grammar syntax for data manipulation
- Main functions:
  - `mutate()` adds new variables that are functions of existing variables
  - `select()` picks variables based on their names.
  - `filter()` picks cases based on their values.
  - `summarise()` reduces multiple values down to a single summary.
  - `arrange()` changes the ordering of the rows.
  - `group_by` select and apply the functions above to specific value

---

.pl[
## `mutate` and `transmute`

- Create new variables in a consistent way
- `mutate()` adds new variables and preserves existing ones
- `transmute()` adds new variables and drops existing ones.
- Both functions preserve the number of rows of the input.
- New variables overwrite existing variables of the same name.

Old way:


```r
survey_2$age_2 &lt;- survey_2$age^2
survey_2$log_age &lt;- log(survey_2$age)
survey_2 %&gt;% head(3)
```

```
## # A tibble: 3 x 6
##   sex       age educ                    mast1 age_2 log_age
##   &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;                   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 FEMALES    24 COMPLETED UNDERGRADUATE     2   576    3.18
## 2 MALES      39 COMPLETED UNDERGRADUATE     2  1521    3.66
## 3 FEMALES    48 SOME SECONDARY              3  2304    3.87
```

]

.pr[


Tidy way:


```r
survey_2 &lt;- survey_2 %&gt;%
  mutate(age_2=age^2
         , log_age= age %&gt;%
           log())
head(survey, 3)
```

```
##    id     sex age             marital child                    educ
## 1 415 FEMALES  24  MARRIED FIRST TIME   YES COMPLETED UNDERGRADUATE
## 2   9   MALES  39 LIVING WITH PARTNER   YES COMPLETED UNDERGRADUATE
## 3 425 FEMALES  48  MARRIED FIRST TIME   YES          SOME SECONDARY
##            source smoke smokenum op1 op2 op3 op4 op5 op6 mast1 mast2 mast3
## 1 LIFE IN GENERAL    NO       NA   3   2   3   2   4   2     2     4     2
## 2            WORK   YES        2   2   3   4   3   5   4     2     4     2
## 3        CHILDREN    NO       NA   3   1   3   3   3   4     3     3     2
##   mast4 mast5 mast6 mast7 pn1 pn2 pn3 pn4 pn5 pn6 pn7 pn8 pn9 pn10 pn11
## 1     2     4     2     3   5   5   4   4   4   5   5   5   5    5    5
## 2     3     4     2     3   4   5   4   5   3   3   3   2   5    4    4
## 3     3     3     2     2   2   1   2   2   1   1   3   1   1    1    1
##   pn12 pn13 pn14 pn15 pn16 pn17 pn18 pn19 pn20 lifsat1 lifsat2 lifsat3
## 1    5    5    3    5    3    5    5    4    4       5       6       5
## 2    4    4    3    2    2    2    3    4    4       7       6       5
## 3    1    1    2    2    2    1    1    2    1       7       7       7
##   lifsat4 lifsat5 pss1 pss2 pss3 pss4 pss5 pss6 pss7 pss8 pss9 pss10 sest1
## 1       4       3    3    3    4    3    4    3    3    3    3     2     4
## 2       7       5    2    2    3    5    4    3    5    4    3     3     3
## 3       6       6    1    2    2    4    4    2    4    4    2     2     4
##   sest2 sest3 sest4 sest5 sest6 sest7 sest8 sest9 sest10 m1 m2 m3 m4 m5 m6
## 1     4     1     4     1     4     2     4     3      3  1  0  1  1  0  0
## 2     4     1     4     1     4     3     3     1      3  1  1  1  0  1  0
## 3     3     3     3     1     3     2     3     2      2  1  1  1  1  1  0
##   m7 m8 m9 m10 pc1 pc2 pc3 pc4 pc5 pc6 pc7 pc8 pc9 pc10 pc11 pc12 pc13
## 1  1  0  0   0   4   4   3   3   4   4   4   2   3    2    4    4    2
## 2  0  1  0   0   4   3   3   4   3   2   5   1   1    1    5    2    4
## 3  1  1  0   1   3   3   4   2   3   3   3   3   3    3    4    3    2
##   pc14 pc15 pc16 pc17 pc18 Rop2 Rop4 Rop6 Rmast1 Rmast3 Rmast4 Rmast6
## 1    2    3    3    4    4    4    4    4      3      3      3      3
## 2    2    4    2    2    2    3    3    2      3      3      2      3
## 3    2    4    4    2    2    5    3    2      2      3      2      3
##   Rmast7 Rpss4 Rpss5 Rpss7 Rpss8 Rsest3 Rsest5 Rsest7 Rsest9 Rsest10 Rpc1
## 1      2     3     2     3     3      4      4      3      2       2    2
## 2      2     1     2     1     2      4      4      2      4       2    2
## 3      3     2     2     2     2      2      4      3      3       3    3
##   Rpc2 Rpc7 Rpc11 Rpc15 Rpc16 toptim tmast tposaff tnegaff tlifesat
## 1    2    2     2     3     3     22    22      49      39       23
## 2    3    1     1     2     4     19    21      35      35       30
## 3    3    3     2     2     2     19    19      15      14       33
##   tpstress tslfest tmarlow tpcoiss  agegp3  agegp5
## 1       29      35       4      51 18 - 29 18 - 24
## 2       22      34       5      40 30 - 44 33 - 40
## 3       19      31       8      47     45+ 41 - 49
##                        educrec LG10negaff     MAH_1        COO_1    MAH_2
## 1      completed undergrad uni   1.623249 0.9580162 4.534498e-05 18.10064
## 2      completed undergrad uni   1.544068 3.6407533 1.585239e-02 14.48201
## 3 did not complete high school   1.146128 1.3074179 1.404248e-02 14.21429
```


```r
survey_2 %&gt;%
  transmute(age_2=age^2
         , log_age= age %&gt;%
           log()) %&gt;%
  head(3)
```

```
## # A tibble: 3 x 2
##   age_2 log_age
##   &lt;dbl&gt;   &lt;dbl&gt;
## 1   576    3.18
## 2  1521    3.66
## 3  2304    3.87
```
]

---

.pl[
# `select` and `rename`

- Choose or rename variables from a tbl
- `select()` keeps only the variables you mention
- `rename()` keeps all variables.
- `:` to include ranges of variables
- `-` to exclude them
- Associated subfunctions:
  - `starts_with()`: Starts with a prefix.
  - `ends_with()`: Ends with a suffix.
  - `contains()`: Contains a literal string.
  - `matches()`: Matches a regular expression.
  - `num_range()`: Matches a numerical range like x01, x02, x03.
  - `one_of()`: Matches variable names in a character vector.
  - `everything()`: Matches all variables.
  - `last_col()`: Select last variable, possibly with an offset.

### Old way


```r
survey_2[,"age"] %&gt;% head(3)
```

```
## # A tibble: 3 x 1
##     age
##   &lt;dbl&gt;
## 1    24
## 2    39
## 3    48
```

]

--

.pr[
### Tidy way


```r
survey %&gt;%
  select(age) %&gt;%
  head(3)
```

```
##   age
## 1  24
## 2  39
## 3  48
```

```r
survey %&gt;%
  select(edad=age) %&gt;%
  head(3)
```

```
##   edad
## 1   24
## 2   39
## 3   48
```

```r
survey %&gt;%
  select(contains("age")) %&gt;%
  head(3)
```

```
##   age  agegp3  agegp5
## 1  24 18 - 29 18 - 24
## 2  39 30 - 44 33 - 40
## 3  48     45+ 41 - 49
```


]

---

.pl[
# `filter`

- Use filter() to choose rows/cases where conditions are true. Unlike base subsetting with brackets, rows where the condition evaluates to NA are dropped.
- Useful functions
    - `==, &gt;, &gt;= etc`
    - `&amp;, |, !, xor()`
    - `is.na()`
    - `between(), near()`
    
### Old way


```r
survey_2[survey_2$sex=="FEMALES",] %&gt;% head(3)
```

```
## # A tibble: 3 x 6
##   sex       age educ                    mast1 age_2 log_age
##   &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;                   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 FEMALES    24 COMPLETED UNDERGRADUATE     2   576    3.18
## 2 FEMALES    48 SOME SECONDARY              3  2304    3.87
## 3 FEMALES    31 COMPLETED UNDERGRADUATE     1   961    3.43
```

]

.pr[
### Tidy way


```r
survey_2 %&gt;%
  filter(sex=="FEMALES") %&gt;%
  head(3)
```

```
## # A tibble: 3 x 6
##   sex       age educ                    mast1 age_2 log_age
##   &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;                   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 FEMALES    24 COMPLETED UNDERGRADUATE     2   576    3.18
## 2 FEMALES    48 SOME SECONDARY              3  2304    3.87
## 3 FEMALES    31 COMPLETED UNDERGRADUATE     1   961    3.43
```


```r
survey_2 %&gt;%
  filter(sex=="FEMALES" &amp; age_2==576) %&gt;% head(3)
```

```
## # A tibble: 3 x 6
##   sex       age educ                     mast1 age_2 log_age
##   &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;                    &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 FEMALES    24 COMPLETED UNDERGRADUATE      2   576    3.18
## 2 FEMALES    24 SOME ADDITIONAL TRAINING     3   576    3.18
## 3 FEMALES    24 SOME ADDITIONAL TRAINING     3   576    3.18
```

]


---

.pl[
# `summarise` and `group_by`

- Create one or more scalar variables summarizing the variables of an existing tbl.
- Tbls with groups created by `group_by()` will result in one row in the output for each group.
- Tbls with no groups will result in one row.
- Also `summarize` with *z* works
- Useful functions: `mean(), median()`, `sd()`, `IQR()`, `mad()`, `min()`, `max()`, `quantile()`
  ,`first()`, `last()`, `nth()`, `n()`, `n_distinct()`, `any()`, `all()`

### Old way (The struggle was real!)


```r
aggregate(survey_2$age, by=list(survey_2$educ, survey_2$sex), FUN=mean)
```

```
##                     Group.1 Group.2        x
## 1            SOME SECONDARY   MALES 46.71429
## 2      COMPLETED HIGHSCHOOL   MALES 22.85714
## 3  SOME ADDITIONAL TRAINING   MALES 39.28571
## 4   COMPLETED UNDERGRADUATE   MALES 34.00000
## 5    POSTGRADUATE COMPLETED   MALES 50.00000
## 6            SOME SECONDARY FEMALES 43.21429
## 7      COMPLETED HIGHSCHOOL FEMALES 37.90000
## 8  SOME ADDITIONAL TRAINING FEMALES 38.40000
## 9   COMPLETED UNDERGRADUATE FEMALES 27.76923
## 10   POSTGRADUATE COMPLETED FEMALES 41.00000
```
]

.pr[
### Tidy way


```r
survey_2 %&gt;%
  group_by(educ, sex) %&gt;%
  summarise(mean_age=mean(age))
```

```
## # A tibble: 10 x 3
## # Groups:   educ [5]
##    educ                     sex     mean_age
##    &lt;fct&gt;                    &lt;fct&gt;      &lt;dbl&gt;
##  1 SOME SECONDARY           MALES       46.7
##  2 SOME SECONDARY           FEMALES     43.2
##  3 COMPLETED HIGHSCHOOL     MALES       22.9
##  4 COMPLETED HIGHSCHOOL     FEMALES     37.9
##  5 SOME ADDITIONAL TRAINING MALES       39.3
##  6 SOME ADDITIONAL TRAINING FEMALES     38.4
##  7 COMPLETED UNDERGRADUATE  MALES       34  
##  8 COMPLETED UNDERGRADUATE  FEMALES     27.8
##  9 POSTGRADUATE COMPLETED   MALES       50  
## 10 POSTGRADUATE COMPLETED   FEMALES     41
```
]

- Note that tibble "remember" the last grouping variable, therefore, any further transformation will be indexed by such variable. Use `ungroup()` to clear.

---

.pl[
# `arrange`

- Order tbl rows by an expression involving its variables.

### Old way


```r
head(survey_2)[order(head(survey_2$age)),]
```

```
## # A tibble: 6 x 6
##   sex       age educ                    mast1 age_2 log_age
##   &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;                   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 MALES      23 COMPLETED UNDERGRADUATE     1   529    3.14
## 2 FEMALES    24 COMPLETED UNDERGRADUATE     2   576    3.18
## 3 FEMALES    31 COMPLETED UNDERGRADUATE     1   961    3.43
## 4 MALES      39 COMPLETED UNDERGRADUATE     2  1521    3.66
## 5 MALES      41 SOME SECONDARY              2  1681    3.71
## 6 FEMALES    48 SOME SECONDARY              3  2304    3.87
```

]

.pr



```r
head(survey_2) %&gt;%
  arrange(age)
```

```
## # A tibble: 6 x 6
##   sex       age educ                    mast1 age_2 log_age
##   &lt;fct&gt;   &lt;dbl&gt; &lt;fct&gt;                   &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;
## 1 MALES      23 COMPLETED UNDERGRADUATE     1   529    3.14
## 2 FEMALES    24 COMPLETED UNDERGRADUATE     2   576    3.18
## 3 FEMALES    31 COMPLETED UNDERGRADUATE     1   961    3.43
## 4 MALES      39 COMPLETED UNDERGRADUATE     2  1521    3.66
## 5 MALES      41 SOME SECONDARY              2  1681    3.71
## 6 FEMALES    48 SOME SECONDARY              3  2304    3.87
```
]

---
class: inverse

Next session:

1. Combining and separating DFs `tidyr`
1. Reshaping DFs `tidyr`
1. Advance functional programming `purrr`
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "solarized-dark",
"highlightLines": true,
"countIncrementalSlides": false,
"ratio": "16:9"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();</script>

<script>
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
